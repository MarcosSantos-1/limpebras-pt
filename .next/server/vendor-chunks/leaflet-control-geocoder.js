/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/leaflet-control-geocoder";
exports.ids = ["vendor-chunks/leaflet-control-geocoder"];
exports.modules = {

/***/ "(ssr)/./node_modules/leaflet-control-geocoder/dist/Control.Geocoder.js":
/*!************************************************************************!*\
  !*** ./node_modules/leaflet-control-geocoder/dist/Control.Geocoder.js ***!
  \************************************************************************/
/***/ (() => {

eval("var leafletControlGeocoder = (function (exports, L) {\n\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n      Object.keys(e).forEach(function (k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () {\n              return e[k];\n            }\n          });\n        }\n      });\n    }\n    n['default'] = e;\n    return n;\n  }\n\n  var L__namespace = /*#__PURE__*/_interopNamespace(L);\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  /**\r\n   * @internal\r\n   */\n\n  function geocodingParams(options, params) {\n    return L__namespace.Util.extend(params, options.geocodingQueryParams);\n  }\n  /**\r\n   * @internal\r\n   */\n\n  function reverseParams(options, params) {\n    return L__namespace.Util.extend(params, options.reverseQueryParams);\n  }\n\n  /**\r\n   * @internal\r\n   */\n\n  var lastCallbackId = 0; // Adapted from handlebars.js\n  // https://github.com/wycats/handlebars.js/\n\n  /**\r\n   * @internal\r\n   */\n\n  var badChars = /[&<>\"'`]/g;\n  /**\r\n   * @internal\r\n   */\n\n  var possible = /[&<>\"'`]/;\n  /**\r\n   * @internal\r\n   */\n\n  var escape = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  /**\r\n   * @internal\r\n   */\n\n  function escapeChar(chr) {\n    return escape[chr];\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  function htmlEscape(string) {\n    if (string == null) {\n      return '';\n    } else if (!string) {\n      return string + '';\n    } // Force a string conversion as this will be done by the append regardless and\n    // the regex test will do this transparently behind the scenes, causing issues if\n    // an object's to string has escaped characters in it.\n\n\n    string = '' + string;\n\n    if (!possible.test(string)) {\n      return string;\n    }\n\n    return string.replace(badChars, escapeChar);\n  }\n  /**\r\n   * @internal\r\n   */\n\n  function jsonp(url, params, callback, context, jsonpParam) {\n    var callbackId = '_l_geocoder_' + lastCallbackId++;\n    params[jsonpParam || 'callback'] = callbackId;\n    window[callbackId] = L__namespace.Util.bind(callback, context);\n    var script = document.createElement('script');\n    script.type = 'text/javascript';\n    script.src = url + getParamString(params);\n    script.id = callbackId;\n    document.getElementsByTagName('head')[0].appendChild(script);\n  }\n  /**\r\n   * @internal\r\n   */\n\n  function getJSON(url, params, callback) {\n    var xmlHttp = new XMLHttpRequest();\n\n    xmlHttp.onreadystatechange = function () {\n      if (xmlHttp.readyState !== 4) {\n        return;\n      }\n\n      var message;\n\n      if (xmlHttp.status !== 200 && xmlHttp.status !== 304) {\n        message = '';\n      } else if (typeof xmlHttp.response === 'string') {\n        // IE doesn't parse JSON responses even with responseType: 'json'.\n        try {\n          message = JSON.parse(xmlHttp.response);\n        } catch (e) {\n          // Not a JSON response\n          message = xmlHttp.response;\n        }\n      } else {\n        message = xmlHttp.response;\n      }\n\n      callback(message);\n    };\n\n    xmlHttp.open('GET', url + getParamString(params), true);\n    xmlHttp.responseType = 'json';\n    xmlHttp.setRequestHeader('Accept', 'application/json');\n    xmlHttp.send(null);\n  }\n  /**\r\n   * @internal\r\n   */\n\n  function template(str, data) {\n    return str.replace(/\\{ *([\\w_]+) *\\}/g, function (str, key) {\n      var value = data[key];\n\n      if (value === undefined) {\n        value = '';\n      } else if (typeof value === 'function') {\n        value = value(data);\n      }\n\n      return htmlEscape(value);\n    });\n  }\n  /**\r\n   * @internal\r\n   */\n\n  function getParamString(obj, existingUrl, uppercase) {\n    var params = [];\n\n    for (var i in obj) {\n      var key = encodeURIComponent(uppercase ? i.toUpperCase() : i);\n      var value = obj[i];\n\n      if (!Array.isArray(value)) {\n        params.push(key + '=' + encodeURIComponent(String(value)));\n      } else {\n        for (var j = 0; j < value.length; j++) {\n          params.push(key + '=' + encodeURIComponent(value[j]));\n        }\n      }\n    }\n\n    return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');\n  }\n\n  /**\r\n   * Implementation of the [ArcGIS geocoder](https://developers.arcgis.com/features/geocoding/)\r\n   */\n\n  var ArcGis = /*#__PURE__*/function () {\n    function ArcGis(options) {\n      this.options = {\n        serviceUrl: 'https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer',\n        apiKey: ''\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = ArcGis.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        token: this.options.apiKey,\n        SingleLine: query,\n        outFields: 'Addr_Type',\n        forStorage: false,\n        maxLocations: 10,\n        f: 'json'\n      });\n      getJSON(this.options.serviceUrl + '/findAddressCandidates', params, function (data) {\n        var results = [];\n\n        if (data.candidates && data.candidates.length) {\n          for (var i = 0; i <= data.candidates.length - 1; i++) {\n            var loc = data.candidates[i];\n            var latLng = L__namespace.latLng(loc.location.y, loc.location.x);\n            var latLngBounds = L__namespace.latLngBounds(L__namespace.latLng(loc.extent.ymax, loc.extent.xmax), L__namespace.latLng(loc.extent.ymin, loc.extent.xmin));\n            results[i] = {\n              name: loc.address,\n              bbox: latLngBounds,\n              center: latLng\n            };\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    _proto.suggest = function suggest(query, cb, context) {\n      return this.geocode(query, cb, context);\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        location: location.lng + ',' + location.lat,\n        distance: 100,\n        f: 'json'\n      });\n      getJSON(this.options.serviceUrl + '/reverseGeocode', params, function (data) {\n        var result = [];\n\n        if (data && !data.error) {\n          var center = L__namespace.latLng(data.location.y, data.location.x);\n          var bbox = L__namespace.latLngBounds(center, center);\n          result.push({\n            name: data.address.Match_addr,\n            center: center,\n            bbox: bbox\n          });\n        }\n\n        cb.call(context, result);\n      });\n    };\n\n    return ArcGis;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link ArcGis}\r\n   * @param options the options\r\n   */\n\n  function arcgis(options) {\n    return new ArcGis(options);\n  }\n\n  /**\r\n   * Implementation of the [Bing Locations API](https://docs.microsoft.com/en-us/bingmaps/rest-services/locations/)\r\n   */\n\n  var Bing = /*#__PURE__*/function () {\n    function Bing(options) {\n      this.options = {\n        serviceUrl: 'https://dev.virtualearth.net/REST/v1/Locations'\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = Bing.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        query: query,\n        key: this.options.apiKey\n      });\n      jsonp(this.options.apiKey, params, function (data) {\n        var results = [];\n\n        if (data.resourceSets.length > 0) {\n          for (var i = data.resourceSets[0].resources.length - 1; i >= 0; i--) {\n            var resource = data.resourceSets[0].resources[i],\n                bbox = resource.bbox;\n            results[i] = {\n              name: resource.name,\n              bbox: L__namespace.latLngBounds([bbox[0], bbox[1]], [bbox[2], bbox[3]]),\n              center: L__namespace.latLng(resource.point.coordinates)\n            };\n          }\n        }\n\n        cb.call(context, results);\n      }, this, 'jsonp');\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        key: this.options.apiKey\n      });\n      jsonp(this.options.serviceUrl + location.lat + ',' + location.lng, params, function (data) {\n        var results = [];\n\n        for (var i = data.resourceSets[0].resources.length - 1; i >= 0; i--) {\n          var resource = data.resourceSets[0].resources[i],\n              bbox = resource.bbox;\n          results[i] = {\n            name: resource.name,\n            bbox: L__namespace.latLngBounds([bbox[0], bbox[1]], [bbox[2], bbox[3]]),\n            center: L__namespace.latLng(resource.point.coordinates)\n          };\n        }\n\n        cb.call(context, results);\n      }, this, 'jsonp');\n    };\n\n    return Bing;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Bing}\r\n   * @param options the options\r\n   */\n\n  function bing(options) {\n    return new Bing(options);\n  }\n\n  var Google = /*#__PURE__*/function () {\n    function Google(options) {\n      this.options = {\n        serviceUrl: 'https://maps.googleapis.com/maps/api/geocode/json'\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = Google.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        key: this.options.apiKey,\n        address: query\n      });\n      getJSON(this.options.serviceUrl, params, function (data) {\n        var results = [];\n\n        if (data.results && data.results.length) {\n          for (var i = 0; i <= data.results.length - 1; i++) {\n            var loc = data.results[i];\n            var latLng = L__namespace.latLng(loc.geometry.location);\n            var latLngBounds = L__namespace.latLngBounds(L__namespace.latLng(loc.geometry.viewport.northeast), L__namespace.latLng(loc.geometry.viewport.southwest));\n            results[i] = {\n              name: loc.formatted_address,\n              bbox: latLngBounds,\n              center: latLng,\n              properties: loc.address_components\n            };\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        key: this.options.apiKey,\n        latlng: location.lat + ',' + location.lng\n      });\n      getJSON(this.options.serviceUrl, params, function (data) {\n        var results = [];\n\n        if (data.results && data.results.length) {\n          for (var i = 0; i <= data.results.length - 1; i++) {\n            var loc = data.results[i];\n            var center = L__namespace.latLng(loc.geometry.location);\n            var bbox = L__namespace.latLngBounds(L__namespace.latLng(loc.geometry.viewport.northeast), L__namespace.latLng(loc.geometry.viewport.southwest));\n            results[i] = {\n              name: loc.formatted_address,\n              bbox: bbox,\n              center: center,\n              properties: loc.address_components\n            };\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    return Google;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Google}\r\n   * @param options the options\r\n   */\n\n  function google(options) {\n    return new Google(options);\n  }\n\n  /**\r\n   * Implementation of the [HERE Geocoder API](https://developer.here.com/documentation/geocoder/topics/introduction.html)\r\n   */\n\n  var HERE = /*#__PURE__*/function () {\n    function HERE(options) {\n      this.options = {\n        serviceUrl: 'https://geocoder.api.here.com/6.2/',\n        app_id: '',\n        app_code: '',\n        apiKey: '',\n        maxResults: 5\n      };\n      L__namespace.Util.setOptions(this, options);\n      if (options.apiKey) throw Error('apiKey is not supported, use app_id/app_code instead!');\n    }\n\n    var _proto = HERE.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        searchtext: query,\n        gen: 9,\n        app_id: this.options.app_id,\n        app_code: this.options.app_code,\n        jsonattributes: 1,\n        maxresults: this.options.maxResults\n      });\n      this.getJSON(this.options.serviceUrl + 'geocode.json', params, cb, context);\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var prox = location.lat + ',' + location.lng;\n\n      if (this.options.reverseGeocodeProxRadius) {\n        prox += ',' + this.options.reverseGeocodeProxRadius;\n      }\n\n      var params = reverseParams(this.options, {\n        prox: prox,\n        mode: 'retrieveAddresses',\n        app_id: this.options.app_id,\n        app_code: this.options.app_code,\n        gen: 9,\n        jsonattributes: 1,\n        maxresults: this.options.maxResults\n      });\n      this.getJSON(this.options.serviceUrl + 'reversegeocode.json', params, cb, context);\n    };\n\n    _proto.getJSON = function getJSON$1(url, params, cb, context) {\n      getJSON(url, params, function (data) {\n        var results = [];\n\n        if (data.response.view && data.response.view.length) {\n          for (var i = 0; i <= data.response.view[0].result.length - 1; i++) {\n            var loc = data.response.view[0].result[i].location;\n            var center = L__namespace.latLng(loc.displayPosition.latitude, loc.displayPosition.longitude);\n            var bbox = L__namespace.latLngBounds(L__namespace.latLng(loc.mapView.topLeft.latitude, loc.mapView.topLeft.longitude), L__namespace.latLng(loc.mapView.bottomRight.latitude, loc.mapView.bottomRight.longitude));\n            results[i] = {\n              name: loc.address.label,\n              properties: loc.address,\n              bbox: bbox,\n              center: center\n            };\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    return HERE;\n  }();\n  /**\r\n   * Implementation of the new [HERE Geocoder API](https://developer.here.com/documentation/geocoding-search-api/api-reference-swagger.html)\r\n   */\n\n  var HEREv2 = /*#__PURE__*/function () {\n    function HEREv2(options) {\n      this.options = {\n        serviceUrl: 'https://geocode.search.hereapi.com/v1',\n        apiKey: '',\n        app_id: '',\n        app_code: '',\n        maxResults: 10\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto2 = HEREv2.prototype;\n\n    _proto2.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        q: query,\n        apiKey: this.options.apiKey,\n        limit: this.options.maxResults\n      });\n\n      if (!params.at && !params[\"in\"]) {\n        throw Error('at / in parameters not found. Please define coordinates (at=latitude,longitude) or other (in) in your geocodingQueryParams.');\n      }\n\n      this.getJSON(this.options.serviceUrl + '/discover', params, cb, context);\n    };\n\n    _proto2.reverse = function reverse(location, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        at: location.lat + ',' + location.lng,\n        limit: this.options.reverseGeocodeProxRadius,\n        apiKey: this.options.apiKey\n      });\n      this.getJSON(this.options.serviceUrl + '/revgeocode', params, cb, context);\n    };\n\n    _proto2.getJSON = function getJSON$1(url, params, cb, context) {\n      getJSON(url, params, function (data) {\n        var results = [];\n\n        if (data.items && data.items.length) {\n          for (var i = 0; i <= data.items.length - 1; i++) {\n            var item = data.items[i];\n            var latLng = L__namespace.latLng(item.position.lat, item.position.lng);\n            var bbox = void 0;\n\n            if (item.mapView) {\n              bbox = L__namespace.latLngBounds(L__namespace.latLng(item.mapView.south, item.mapView.west), L__namespace.latLng(item.mapView.north, item.mapView.east));\n            } else {\n              // Using only position when not provided\n              bbox = L__namespace.latLngBounds(L__namespace.latLng(item.position.lat, item.position.lng), L__namespace.latLng(item.position.lat, item.position.lng));\n            }\n\n            results[i] = {\n              name: item.address.label,\n              properties: item.address,\n              bbox: bbox,\n              center: latLng\n            };\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    return HEREv2;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link HERE}\r\n   * @param options the options\r\n   */\n\n  function here(options) {\n    if (options.apiKey) {\n      return new HEREv2(options);\n    } else {\n      return new HERE(options);\n    }\n  }\n\n  /**\r\n   * Parses basic latitude/longitude strings such as `'50.06773 14.37742'`, `'N50.06773 W14.37742'`, `'S 50° 04.064 E 014° 22.645'`, or `'S 50° 4′ 03.828″, W 14° 22′ 38.712″'`\r\n   * @param query the latitude/longitude string to parse\r\n   * @returns the parsed latitude/longitude\r\n   */\n\n  function parseLatLng(query) {\n    var match; // regex from https://github.com/openstreetmap/openstreetmap-website/blob/master/app/controllers/geocoder_controller.rb\n\n    if (match = query.match(/^([NS])\\s*(\\d{1,3}(?:\\.\\d*)?)\\W*([EW])\\s*(\\d{1,3}(?:\\.\\d*)?)$/)) {\n      // [NSEW] decimal degrees\n      return L__namespace.latLng((/N/i.test(match[1]) ? 1 : -1) * +match[2], (/E/i.test(match[3]) ? 1 : -1) * +match[4]);\n    } else if (match = query.match(/^(\\d{1,3}(?:\\.\\d*)?)\\s*([NS])\\W*(\\d{1,3}(?:\\.\\d*)?)\\s*([EW])$/)) {\n      // decimal degrees [NSEW]\n      return L__namespace.latLng((/N/i.test(match[2]) ? 1 : -1) * +match[1], (/E/i.test(match[4]) ? 1 : -1) * +match[3]);\n    } else if (match = query.match(/^([NS])\\s*(\\d{1,3})°?\\s*(\\d{1,3}(?:\\.\\d*)?)?['′]?\\W*([EW])\\s*(\\d{1,3})°?\\s*(\\d{1,3}(?:\\.\\d*)?)?['′]?$/)) {\n      // [NSEW] degrees, decimal minutes\n      return L__namespace.latLng((/N/i.test(match[1]) ? 1 : -1) * (+match[2] + +match[3] / 60), (/E/i.test(match[4]) ? 1 : -1) * (+match[5] + +match[6] / 60));\n    } else if (match = query.match(/^(\\d{1,3})°?\\s*(\\d{1,3}(?:\\.\\d*)?)?['′]?\\s*([NS])\\W*(\\d{1,3})°?\\s*(\\d{1,3}(?:\\.\\d*)?)?['′]?\\s*([EW])$/)) {\n      // degrees, decimal minutes [NSEW]\n      return L__namespace.latLng((/N/i.test(match[3]) ? 1 : -1) * (+match[1] + +match[2] / 60), (/E/i.test(match[6]) ? 1 : -1) * (+match[4] + +match[5] / 60));\n    } else if (match = query.match(/^([NS])\\s*(\\d{1,3})°?\\s*(\\d{1,2})['′]?\\s*(\\d{1,3}(?:\\.\\d*)?)?[\"″]?\\W*([EW])\\s*(\\d{1,3})°?\\s*(\\d{1,2})['′]?\\s*(\\d{1,3}(?:\\.\\d*)?)?[\"″]?$/)) {\n      // [NSEW] degrees, minutes, decimal seconds\n      return L__namespace.latLng((/N/i.test(match[1]) ? 1 : -1) * (+match[2] + +match[3] / 60 + +match[4] / 3600), (/E/i.test(match[5]) ? 1 : -1) * (+match[6] + +match[7] / 60 + +match[8] / 3600));\n    } else if (match = query.match(/^(\\d{1,3})°?\\s*(\\d{1,2})['′]?\\s*(\\d{1,3}(?:\\.\\d*)?)?[\"″]\\s*([NS])\\W*(\\d{1,3})°?\\s*(\\d{1,2})['′]?\\s*(\\d{1,3}(?:\\.\\d*)?)?[\"″]?\\s*([EW])$/)) {\n      // degrees, minutes, decimal seconds [NSEW]\n      return L__namespace.latLng((/N/i.test(match[4]) ? 1 : -1) * (+match[1] + +match[2] / 60 + +match[3] / 3600), (/E/i.test(match[8]) ? 1 : -1) * (+match[5] + +match[6] / 60 + +match[7] / 3600));\n    } else if (match = query.match(/^\\s*([+-]?\\d+(?:\\.\\d*)?)\\s*[\\s,]\\s*([+-]?\\d+(?:\\.\\d*)?)\\s*$/)) {\n      return L__namespace.latLng(+match[1], +match[2]);\n    }\n  }\n  /**\r\n   * Parses basic latitude/longitude strings such as `'50.06773 14.37742'`, `'N50.06773 W14.37742'`, `'S 50° 04.064 E 014° 22.645'`, or `'S 50° 4′ 03.828″, W 14° 22′ 38.712″'`\r\n   */\n\n  var LatLng = /*#__PURE__*/function () {\n    function LatLng(options) {\n      this.options = {\n        next: undefined,\n        sizeInMeters: 10000\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = LatLng.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var center = parseLatLng(query);\n\n      if (center) {\n        var results = [{\n          name: query,\n          center: center,\n          bbox: center.toBounds(this.options.sizeInMeters)\n        }];\n        cb.call(context, results);\n      } else if (this.options.next) {\n        this.options.next.geocode(query, cb, context);\n      }\n    };\n\n    return LatLng;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link LatLng}\r\n   * @param options the options\r\n   */\n\n  function latLng(options) {\n    return new LatLng(options);\n  }\n\n  /**\r\n   * Implementation of the [Mapbox Geocoding](https://www.mapbox.com/api-documentation/#geocoding)\r\n   */\n\n  var Mapbox = /*#__PURE__*/function () {\n    function Mapbox(options) {\n      this.options = {\n        serviceUrl: 'https://api.mapbox.com/geocoding/v5/mapbox.places/'\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = Mapbox.prototype;\n\n    _proto._getProperties = function _getProperties(loc) {\n      var properties = {\n        text: loc.text,\n        address: loc.address\n      };\n\n      for (var j = 0; j < (loc.context || []).length; j++) {\n        var id = loc.context[j].id.split('.')[0];\n        properties[id] = loc.context[j].text; // Get country code when available\n\n        if (loc.context[j].short_code) {\n          properties['countryShortCode'] = loc.context[j].short_code;\n        }\n      }\n\n      return properties;\n    };\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var _this = this;\n\n      var params = geocodingParams(this.options, {\n        access_token: this.options.apiKey\n      });\n\n      if (params.proximity !== undefined && params.proximity.lat !== undefined && params.proximity.lng !== undefined) {\n        params.proximity = params.proximity.lng + ',' + params.proximity.lat;\n      }\n\n      getJSON(this.options.serviceUrl + encodeURIComponent(query) + '.json', params, function (data) {\n        var results = [];\n\n        if (data.features && data.features.length) {\n          for (var i = 0; i <= data.features.length - 1; i++) {\n            var loc = data.features[i];\n            var center = L__namespace.latLng(loc.center.reverse());\n            var bbox = void 0;\n\n            if (loc.bbox) {\n              bbox = L__namespace.latLngBounds(L__namespace.latLng(loc.bbox.slice(0, 2).reverse()), L__namespace.latLng(loc.bbox.slice(2, 4).reverse()));\n            } else {\n              bbox = L__namespace.latLngBounds(center, center);\n            }\n\n            results[i] = {\n              name: loc.place_name,\n              bbox: bbox,\n              center: center,\n              properties: _this._getProperties(loc)\n            };\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    _proto.suggest = function suggest(query, cb, context) {\n      return this.geocode(query, cb, context);\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var _this2 = this;\n\n      var url = this.options.serviceUrl + location.lng + ',' + location.lat + '.json';\n      var param = reverseParams(this.options, {\n        access_token: this.options.apiKey\n      });\n      getJSON(url, param, function (data) {\n        var results = [];\n\n        if (data.features && data.features.length) {\n          for (var i = 0; i <= data.features.length - 1; i++) {\n            var loc = data.features[i];\n            var center = L__namespace.latLng(loc.center.reverse());\n            var bbox = void 0;\n\n            if (loc.bbox) {\n              bbox = L__namespace.latLngBounds(L__namespace.latLng(loc.bbox.slice(0, 2).reverse()), L__namespace.latLng(loc.bbox.slice(2, 4).reverse()));\n            } else {\n              bbox = L__namespace.latLngBounds(center, center);\n            }\n\n            results[i] = {\n              name: loc.place_name,\n              bbox: bbox,\n              center: center,\n              properties: _this2._getProperties(loc)\n            };\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    return Mapbox;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Mapbox}\r\n   * @param options the options\r\n   */\n\n  function mapbox(options) {\n    return new Mapbox(options);\n  }\n\n  /**\r\n   * Implementation of the [MapQuest Geocoding API](http://developer.mapquest.com/web/products/dev-services/geocoding-ws)\r\n   */\n\n  var MapQuest = /*#__PURE__*/function () {\n    function MapQuest(options) {\n      this.options = {\n        serviceUrl: 'https://www.mapquestapi.com/geocoding/v1'\n      };\n      L__namespace.Util.setOptions(this, options); // MapQuest seems to provide URI encoded API keys,\n      // so to avoid encoding them twice, we decode them here\n\n      this.options.apiKey = decodeURIComponent(this.options.apiKey);\n    }\n\n    var _proto = MapQuest.prototype;\n\n    _proto._formatName = function _formatName() {\n      return [].slice.call(arguments).filter(function (s) {\n        return !!s;\n      }).join(', ');\n    };\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        key: this.options.apiKey,\n        location: query,\n        limit: 5,\n        outFormat: 'json'\n      });\n      getJSON(this.options.serviceUrl + '/address', params, L__namespace.Util.bind(function (data) {\n        var results = [];\n\n        if (data.results && data.results[0].locations) {\n          for (var i = data.results[0].locations.length - 1; i >= 0; i--) {\n            var loc = data.results[0].locations[i];\n            var center = L__namespace.latLng(loc.latLng);\n            results[i] = {\n              name: this._formatName(loc.street, loc.adminArea4, loc.adminArea3, loc.adminArea1),\n              bbox: L__namespace.latLngBounds(center, center),\n              center: center\n            };\n          }\n        }\n\n        cb.call(context, results);\n      }, this));\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        key: this.options.apiKey,\n        location: location.lat + ',' + location.lng,\n        outputFormat: 'json'\n      });\n      getJSON(this.options.serviceUrl + '/reverse', params, L__namespace.Util.bind(function (data) {\n        var results = [];\n\n        if (data.results && data.results[0].locations) {\n          for (var i = data.results[0].locations.length - 1; i >= 0; i--) {\n            var loc = data.results[0].locations[i];\n            var center = L__namespace.latLng(loc.latLng);\n            results[i] = {\n              name: this._formatName(loc.street, loc.adminArea4, loc.adminArea3, loc.adminArea1),\n              bbox: L__namespace.latLngBounds(center, center),\n              center: center\n            };\n          }\n        }\n\n        cb.call(context, results);\n      }, this));\n    };\n\n    return MapQuest;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link MapQuest}\r\n   * @param options the options\r\n   */\n\n  function mapQuest(options) {\n    return new MapQuest(options);\n  }\n\n  /**\r\n   * Implementation of the [Neutrino API](https://www.neutrinoapi.com/api/geocode-address/)\r\n   */\n\n  var Neutrino = /*#__PURE__*/function () {\n    function Neutrino(options) {\n      this.options = {\n        userId: undefined,\n        apiKey: undefined,\n        serviceUrl: 'https://neutrinoapi.com/'\n      };\n      L__namespace.Util.setOptions(this, options);\n    } // https://www.neutrinoapi.com/api/geocode-address/\n\n\n    var _proto = Neutrino.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        apiKey: this.options.apiKey,\n        userId: this.options.userId,\n        //get three words and make a dot based string\n        address: query.split(/\\s+/).join('.')\n      });\n      getJSON(this.options.serviceUrl + 'geocode-address', params, function (data) {\n        var results = [];\n\n        if (data.locations) {\n          data.geometry = data.locations[0];\n          var center = L__namespace.latLng(data.geometry['latitude'], data.geometry['longitude']);\n          var bbox = L__namespace.latLngBounds(center, center);\n          results[0] = {\n            name: data.geometry.address,\n            bbox: bbox,\n            center: center\n          };\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    _proto.suggest = function suggest(query, cb, context) {\n      return this.geocode(query, cb, context);\n    } // https://www.neutrinoapi.com/api/geocode-reverse/\n    ;\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        apiKey: this.options.apiKey,\n        userId: this.options.userId,\n        latitude: location.lat,\n        longitude: location.lng\n      });\n      getJSON(this.options.serviceUrl + 'geocode-reverse', params, function (data) {\n        var results = [];\n\n        if (data.status.status == 200 && data.found) {\n          var center = L__namespace.latLng(location.lat, location.lng);\n          var bbox = L__namespace.latLngBounds(center, center);\n          results[0] = {\n            name: data.address,\n            bbox: bbox,\n            center: center\n          };\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    return Neutrino;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Neutrino}\r\n   * @param options the options\r\n   */\n\n  function neutrino(options) {\n    return new Neutrino(options);\n  }\n\n  /**\r\n   * Implementation of the [Nominatim](https://wiki.openstreetmap.org/wiki/Nominatim) geocoder.\r\n   *\r\n   * This is the default geocoding service used by the control, unless otherwise specified in the options.\r\n   *\r\n   * Unless using your own Nominatim installation, please refer to the [Nominatim usage policy](https://operations.osmfoundation.org/policies/nominatim/).\r\n   */\n\n  var Nominatim = /*#__PURE__*/function () {\n    function Nominatim(options) {\n      this.options = {\n        serviceUrl: 'https://nominatim.openstreetmap.org/',\n        htmlTemplate: function htmlTemplate(r) {\n          var address = r.address;\n          var className;\n          var parts = [];\n\n          if (address.road || address.building) {\n            parts.push('{building} {road} {house_number}');\n          }\n\n          if (address.city || address.town || address.village || address.hamlet) {\n            className = parts.length > 0 ? 'leaflet-control-geocoder-address-detail' : '';\n            parts.push('<span class=\"' + className + '\">{postcode} {city} {town} {village} {hamlet}</span>');\n          }\n\n          if (address.state || address.country) {\n            className = parts.length > 0 ? 'leaflet-control-geocoder-address-context' : '';\n            parts.push('<span class=\"' + className + '\">{state} {country}</span>');\n          }\n\n          return template(parts.join('<br/>'), address);\n        }\n      };\n      L__namespace.Util.setOptions(this, options || {});\n    }\n\n    var _proto = Nominatim.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var _this = this;\n\n      var params = geocodingParams(this.options, {\n        q: query,\n        limit: 5,\n        format: 'json',\n        addressdetails: 1\n      });\n      getJSON(this.options.serviceUrl + 'search', params, function (data) {\n        var results = [];\n\n        for (var i = data.length - 1; i >= 0; i--) {\n          var bbox = data[i].boundingbox;\n\n          for (var j = 0; j < 4; j++) {\n            bbox[j] = +bbox[j];\n          }\n\n          results[i] = {\n            icon: data[i].icon,\n            name: data[i].display_name,\n            html: _this.options.htmlTemplate ? _this.options.htmlTemplate(data[i]) : undefined,\n            bbox: L__namespace.latLngBounds([bbox[0], bbox[2]], [bbox[1], bbox[3]]),\n            center: L__namespace.latLng(data[i].lat, data[i].lon),\n            properties: data[i]\n          };\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var _this2 = this;\n\n      var params = reverseParams(this.options, {\n        lat: location.lat,\n        lon: location.lng,\n        zoom: Math.round(Math.log(scale / 256) / Math.log(2)),\n        addressdetails: 1,\n        format: 'json'\n      });\n      getJSON(this.options.serviceUrl + 'reverse', params, function (data) {\n        var result = [];\n\n        if (data && data.lat && data.lon) {\n          var center = L__namespace.latLng(data.lat, data.lon);\n          var bbox = L__namespace.latLngBounds(center, center);\n          result.push({\n            name: data.display_name,\n            html: _this2.options.htmlTemplate ? _this2.options.htmlTemplate(data) : undefined,\n            center: center,\n            bbox: bbox,\n            properties: data\n          });\n        }\n\n        cb.call(context, result);\n      });\n    };\n\n    return Nominatim;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Nominatim}\r\n   * @param options the options\r\n   */\n\n  function nominatim(options) {\n    return new Nominatim(options);\n  }\n\n  /**\r\n   * Implementation of the [Plus codes](https://plus.codes/) (formerly OpenLocationCode) (requires [open-location-code](https://www.npmjs.com/package/open-location-code))\r\n   */\n\n  var OpenLocationCode = /*#__PURE__*/function () {\n    function OpenLocationCode(options) {\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = OpenLocationCode.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      try {\n        var decoded = this.options.OpenLocationCode.decode(query);\n        var result = {\n          name: query,\n          center: L__namespace.latLng(decoded.latitudeCenter, decoded.longitudeCenter),\n          bbox: L__namespace.latLngBounds(L__namespace.latLng(decoded.latitudeLo, decoded.longitudeLo), L__namespace.latLng(decoded.latitudeHi, decoded.longitudeHi))\n        };\n        cb.call(context, [result]);\n      } catch (e) {\n        console.warn(e); // eslint-disable-line no-console\n\n        cb.call(context, []);\n      }\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      try {\n        var code = this.options.OpenLocationCode.encode(location.lat, location.lng, this.options.codeLength);\n        var result = {\n          name: code,\n          center: L__namespace.latLng(location.lat, location.lng),\n          bbox: L__namespace.latLngBounds(L__namespace.latLng(location.lat, location.lng), L__namespace.latLng(location.lat, location.lng))\n        };\n        cb.call(context, [result]);\n      } catch (e) {\n        console.warn(e); // eslint-disable-line no-console\n\n        cb.call(context, []);\n      }\n    };\n\n    return OpenLocationCode;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link OpenLocationCode}\r\n   * @param options the options\r\n   */\n\n  function openLocationCode(options) {\n    return new OpenLocationCode(options);\n  }\n\n  /**\r\n   * Implementation of the [OpenCage Data API](https://opencagedata.com/)\r\n   */\n\n  var OpenCage = /*#__PURE__*/function () {\n    function OpenCage(options) {\n      this.options = {\n        serviceUrl: 'https://api.opencagedata.com/geocode/v1/json'\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = OpenCage.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        key: this.options.apiKey,\n        q: query\n      });\n      getJSON(this.options.serviceUrl, params, function (data) {\n        var results = [];\n\n        if (data.results && data.results.length) {\n          for (var i = 0; i < data.results.length; i++) {\n            var loc = data.results[i];\n            var center = L__namespace.latLng(loc.geometry);\n            var bbox = void 0;\n\n            if (loc.annotations && loc.annotations.bounds) {\n              bbox = L__namespace.latLngBounds(L__namespace.latLng(loc.annotations.bounds.northeast), L__namespace.latLng(loc.annotations.bounds.southwest));\n            } else {\n              bbox = L__namespace.latLngBounds(center, center);\n            }\n\n            results.push({\n              name: loc.formatted,\n              bbox: bbox,\n              center: center\n            });\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    _proto.suggest = function suggest(query, cb, context) {\n      return this.geocode(query, cb, context);\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        key: this.options.apiKey,\n        q: [location.lat, location.lng].join(',')\n      });\n      getJSON(this.options.serviceUrl, params, function (data) {\n        var results = [];\n\n        if (data.results && data.results.length) {\n          for (var i = 0; i < data.results.length; i++) {\n            var loc = data.results[i];\n            var center = L__namespace.latLng(loc.geometry);\n            var bbox = void 0;\n\n            if (loc.annotations && loc.annotations.bounds) {\n              bbox = L__namespace.latLngBounds(L__namespace.latLng(loc.annotations.bounds.northeast), L__namespace.latLng(loc.annotations.bounds.southwest));\n            } else {\n              bbox = L__namespace.latLngBounds(center, center);\n            }\n\n            results.push({\n              name: loc.formatted,\n              bbox: bbox,\n              center: center\n            });\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    return OpenCage;\n  }();\n  function opencage(options) {\n    return new OpenCage(options);\n  }\n\n  /**\r\n   * Implementation of the [Pelias](https://pelias.io/), [geocode.earth](https://geocode.earth/) geocoder (formerly Mapzen Search)\r\n   */\n\n  var Pelias = /*#__PURE__*/function () {\n    function Pelias(options) {\n      this.options = {\n        serviceUrl: 'https://api.geocode.earth/v1'\n      };\n      this._lastSuggest = 0;\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = Pelias.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var _this = this;\n\n      var params = geocodingParams(this.options, {\n        api_key: this.options.apiKey,\n        text: query\n      });\n      getJSON(this.options.serviceUrl + '/search', params, function (data) {\n        cb.call(context, _this._parseResults(data, 'bbox'));\n      });\n    };\n\n    _proto.suggest = function suggest(query, cb, context) {\n      var _this2 = this;\n\n      var params = geocodingParams(this.options, {\n        api_key: this.options.apiKey,\n        text: query\n      });\n      getJSON(this.options.serviceUrl + '/autocomplete', params, function (data) {\n        if (data.geocoding.timestamp > _this2._lastSuggest) {\n          _this2._lastSuggest = data.geocoding.timestamp;\n          cb.call(context, _this2._parseResults(data, 'bbox'));\n        }\n      });\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var _this3 = this;\n\n      var params = reverseParams(this.options, {\n        api_key: this.options.apiKey,\n        'point.lat': location.lat,\n        'point.lon': location.lng\n      });\n      getJSON(this.options.serviceUrl + '/reverse', params, function (data) {\n        cb.call(context, _this3._parseResults(data, 'bounds'));\n      });\n    };\n\n    _proto._parseResults = function _parseResults(data, bboxname) {\n      var results = [];\n      L__namespace.geoJSON(data, {\n        pointToLayer: function pointToLayer(feature, latlng) {\n          return L__namespace.circleMarker(latlng);\n        },\n        onEachFeature: function onEachFeature(feature, layer) {\n          var result = {};\n          var bbox;\n          var center;\n\n          if (layer.getBounds) {\n            bbox = layer.getBounds();\n            center = bbox.getCenter();\n          } else if (layer.feature.bbox) {\n            center = layer.getLatLng();\n            bbox = L__namespace.latLngBounds(L__namespace.GeoJSON.coordsToLatLng(layer.feature.bbox.slice(0, 2)), L__namespace.GeoJSON.coordsToLatLng(layer.feature.bbox.slice(2, 4)));\n          } else {\n            center = layer.getLatLng();\n            bbox = L__namespace.latLngBounds(center, center);\n          }\n\n          result.name = layer.feature.properties.label;\n          result.center = center;\n          result[bboxname] = bbox;\n          result.properties = layer.feature.properties;\n          results.push(result);\n        }\n      });\n      return results;\n    };\n\n    return Pelias;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Pelias}\r\n   * @param options the options\r\n   */\n\n  function pelias(options) {\n    return new Pelias(options);\n  }\n  var GeocodeEarth = Pelias;\n  var geocodeEarth = pelias;\n  /**\r\n   * r.i.p.\r\n   * @deprecated\r\n   */\n\n  var Mapzen = Pelias;\n  /**\r\n   * r.i.p.\r\n   * @deprecated\r\n   */\n\n  var mapzen = pelias;\n  /**\r\n   * Implementation of the [Openrouteservice](https://openrouteservice.org/dev/#/api-docs/geocode) geocoder\r\n   */\n\n  var Openrouteservice = /*#__PURE__*/function (_Pelias) {\n    _inheritsLoose(Openrouteservice, _Pelias);\n\n    function Openrouteservice(options) {\n      return _Pelias.call(this, L__namespace.Util.extend({\n        serviceUrl: 'https://api.openrouteservice.org/geocode'\n      }, options)) || this;\n    }\n\n    return Openrouteservice;\n  }(Pelias);\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Openrouteservice}\r\n   * @param options the options\r\n   */\n\n  function openrouteservice(options) {\n    return new Openrouteservice(options);\n  }\n\n  /**\r\n   * Implementation of the [Photon](http://photon.komoot.de/) geocoder\r\n   */\n\n  var Photon = /*#__PURE__*/function () {\n    function Photon(options) {\n      this.options = {\n        serviceUrl: 'https://photon.komoot.io/api/',\n        reverseUrl: 'https://photon.komoot.io/reverse/',\n        nameProperties: ['name', 'street', 'suburb', 'hamlet', 'town', 'city', 'state', 'country']\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = Photon.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        q: query\n      });\n      getJSON(this.options.serviceUrl, params, L__namespace.Util.bind(function (data) {\n        cb.call(context, this._decodeFeatures(data));\n      }, this));\n    };\n\n    _proto.suggest = function suggest(query, cb, context) {\n      return this.geocode(query, cb, context);\n    };\n\n    _proto.reverse = function reverse(latLng, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        lat: latLng.lat,\n        lon: latLng.lng\n      });\n      getJSON(this.options.reverseUrl, params, L__namespace.Util.bind(function (data) {\n        cb.call(context, this._decodeFeatures(data));\n      }, this));\n    };\n\n    _proto._decodeFeatures = function _decodeFeatures(data) {\n      var results = [];\n\n      if (data && data.features) {\n        for (var i = 0; i < data.features.length; i++) {\n          var f = data.features[i];\n          var c = f.geometry.coordinates;\n          var center = L__namespace.latLng(c[1], c[0]);\n          var extent = f.properties.extent;\n          var bbox = extent ? L__namespace.latLngBounds([extent[1], extent[0]], [extent[3], extent[2]]) : L__namespace.latLngBounds(center, center);\n          results.push({\n            name: this._decodeFeatureName(f),\n            html: this.options.htmlTemplate ? this.options.htmlTemplate(f) : undefined,\n            center: center,\n            bbox: bbox,\n            properties: f.properties\n          });\n        }\n      }\n\n      return results;\n    };\n\n    _proto._decodeFeatureName = function _decodeFeatureName(f) {\n      return (this.options.nameProperties || []).map(function (p) {\n        return f.properties[p];\n      }).filter(function (v) {\n        return !!v;\n      }).join(', ');\n    };\n\n    return Photon;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Photon}\r\n   * @param options the options\r\n   */\n\n  function photon(options) {\n    return new Photon(options);\n  }\n\n  /**\r\n   * Implementation of the What3Words service\r\n   */\n\n  var What3Words = /*#__PURE__*/function () {\n    function What3Words(options) {\n      this.options = {\n        serviceUrl: 'https://api.what3words.com/v2/'\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = What3Words.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      //get three words and make a dot based string\n      getJSON(this.options.serviceUrl + 'forward', geocodingParams(this.options, {\n        key: this.options.apiKey,\n        addr: query.split(/\\s+/).join('.')\n      }), function (data) {\n        var results = [];\n\n        if (data.geometry) {\n          var latLng = L__namespace.latLng(data.geometry['lat'], data.geometry['lng']);\n          var latLngBounds = L__namespace.latLngBounds(latLng, latLng);\n          results[0] = {\n            name: data.words,\n            bbox: latLngBounds,\n            center: latLng\n          };\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    _proto.suggest = function suggest(query, cb, context) {\n      return this.geocode(query, cb, context);\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      getJSON(this.options.serviceUrl + 'reverse', reverseParams(this.options, {\n        key: this.options.apiKey,\n        coords: [location.lat, location.lng].join(',')\n      }), function (data) {\n        var results = [];\n\n        if (data.status.status == 200) {\n          var center = L__namespace.latLng(data.geometry['lat'], data.geometry['lng']);\n          var bbox = L__namespace.latLngBounds(center, center);\n          results[0] = {\n            name: data.words,\n            bbox: bbox,\n            center: center\n          };\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    return What3Words;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link What3Words}\r\n   * @param options the options\r\n   */\n\n  function what3words(options) {\n    return new What3Words(options);\n  }\n\n  var geocoders = {\n    __proto__: null,\n    geocodingParams: geocodingParams,\n    reverseParams: reverseParams,\n    ArcGis: ArcGis,\n    arcgis: arcgis,\n    Bing: Bing,\n    bing: bing,\n    Google: Google,\n    google: google,\n    HERE: HERE,\n    HEREv2: HEREv2,\n    here: here,\n    parseLatLng: parseLatLng,\n    LatLng: LatLng,\n    latLng: latLng,\n    Mapbox: Mapbox,\n    mapbox: mapbox,\n    MapQuest: MapQuest,\n    mapQuest: mapQuest,\n    Neutrino: Neutrino,\n    neutrino: neutrino,\n    Nominatim: Nominatim,\n    nominatim: nominatim,\n    OpenLocationCode: OpenLocationCode,\n    openLocationCode: openLocationCode,\n    OpenCage: OpenCage,\n    opencage: opencage,\n    Pelias: Pelias,\n    pelias: pelias,\n    GeocodeEarth: GeocodeEarth,\n    geocodeEarth: geocodeEarth,\n    Mapzen: Mapzen,\n    mapzen: mapzen,\n    Openrouteservice: Openrouteservice,\n    openrouteservice: openrouteservice,\n    Photon: Photon,\n    photon: photon,\n    What3Words: What3Words,\n    what3words: what3words\n  };\n\n  /**\r\n   * Leaflet mixins https://leafletjs.com/reference-1.7.1.html#class-includes\r\n   * for TypeScript https://www.typescriptlang.org/docs/handbook/mixins.html\r\n   * @internal\r\n   */\n\n  var EventedControl = // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function EventedControl() {// empty\n  };\n\n  L__namespace.Util.extend(EventedControl.prototype, L__namespace.Control.prototype);\n  L__namespace.Util.extend(EventedControl.prototype, L__namespace.Evented.prototype);\n  /**\r\n   * This is the geocoder control. It works like any other [Leaflet control](https://leafletjs.com/reference.html#control), and is added to the map.\r\n   */\n\n  var GeocoderControl = /*#__PURE__*/function (_EventedControl) {\n    _inheritsLoose(GeocoderControl, _EventedControl);\n\n    /**\r\n     * Instantiates a geocoder control (to be invoked using `new`)\r\n     * @param options the options\r\n     */\n    function GeocoderControl(options) {\n      var _this;\n\n      _this = _EventedControl.call(this, options) || this;\n      _this.options = {\n        showUniqueResult: true,\n        showResultIcons: false,\n        collapsed: true,\n        expand: 'touch',\n        position: 'topright',\n        placeholder: 'Search...',\n        errorMessage: 'Nothing found.',\n        iconLabel: 'Initiate a new search',\n        query: '',\n        queryMinLength: 1,\n        suggestMinLength: 3,\n        suggestTimeout: 250,\n        defaultMarkGeocode: true\n      };\n      _this._requestCount = 0;\n      L__namespace.Util.setOptions(_assertThisInitialized(_this), options);\n\n      if (!_this.options.geocoder) {\n        _this.options.geocoder = new Nominatim();\n      }\n\n      return _this;\n    }\n\n    var _proto = GeocoderControl.prototype;\n\n    _proto.addThrobberClass = function addThrobberClass() {\n      L__namespace.DomUtil.addClass(this._container, 'leaflet-control-geocoder-throbber');\n    };\n\n    _proto.removeThrobberClass = function removeThrobberClass() {\n      L__namespace.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-throbber');\n    }\n    /**\r\n     * Returns the container DOM element for the control and add listeners on relevant map events.\r\n     * @param map the map instance\r\n     * @see https://leafletjs.com/reference.html#control-onadd\r\n     */\n    ;\n\n    _proto.onAdd = function onAdd(map) {\n      var _this2 = this;\n\n      var className = 'leaflet-control-geocoder';\n      var container = L__namespace.DomUtil.create('div', className + ' leaflet-bar');\n      var icon = L__namespace.DomUtil.create('button', className + '-icon', container);\n      var form = this._form = L__namespace.DomUtil.create('div', className + '-form', container);\n      this._map = map;\n      this._container = container;\n      icon.innerHTML = '&nbsp;';\n      icon.type = 'button';\n      icon.setAttribute('aria-label', this.options.iconLabel);\n      var input = this._input = L__namespace.DomUtil.create('input', '', form);\n      input.type = 'text';\n      input.value = this.options.query;\n      input.placeholder = this.options.placeholder;\n      L__namespace.DomEvent.disableClickPropagation(input);\n      this._errorElement = L__namespace.DomUtil.create('div', className + '-form-no-error', container);\n      this._errorElement.innerHTML = this.options.errorMessage;\n      this._alts = L__namespace.DomUtil.create('ul', className + '-alternatives leaflet-control-geocoder-alternatives-minimized', container);\n      L__namespace.DomEvent.disableClickPropagation(this._alts);\n      L__namespace.DomEvent.addListener(input, 'keydown', this._keydown, this);\n\n      if (this.options.geocoder.suggest) {\n        L__namespace.DomEvent.addListener(input, 'input', this._change, this);\n      }\n\n      L__namespace.DomEvent.addListener(input, 'blur', function () {\n        if (_this2.options.collapsed && !_this2._preventBlurCollapse) {\n          _this2._collapse();\n        }\n\n        _this2._preventBlurCollapse = false;\n      });\n\n      if (this.options.collapsed) {\n        if (this.options.expand === 'click') {\n          L__namespace.DomEvent.addListener(container, 'click', function (e) {\n            if (e.button === 0 && e.detail !== 2) {\n              _this2._toggle();\n            }\n          });\n        } else if (this.options.expand === 'touch') {\n          L__namespace.DomEvent.addListener(container, L__namespace.Browser.touch ? 'touchstart mousedown' : 'mousedown', function (e) {\n            _this2._toggle();\n\n            e.preventDefault(); // mobile: clicking focuses the icon, so UI expands and immediately collapses\n\n            e.stopPropagation();\n          }, this);\n        } else {\n          L__namespace.DomEvent.addListener(container, 'mouseover', this._expand, this);\n          L__namespace.DomEvent.addListener(container, 'mouseout', this._collapse, this);\n\n          this._map.on('movestart', this._collapse, this);\n        }\n      } else {\n        this._expand();\n\n        if (L__namespace.Browser.touch) {\n          L__namespace.DomEvent.addListener(container, 'touchstart', function () {\n            return _this2._geocode();\n          });\n        } else {\n          L__namespace.DomEvent.addListener(container, 'click', function () {\n            return _this2._geocode();\n          });\n        }\n      }\n\n      if (this.options.defaultMarkGeocode) {\n        this.on('markgeocode', this.markGeocode, this);\n      }\n\n      this.on('startgeocode', this.addThrobberClass, this);\n      this.on('finishgeocode', this.removeThrobberClass, this);\n      this.on('startsuggest', this.addThrobberClass, this);\n      this.on('finishsuggest', this.removeThrobberClass, this);\n      L__namespace.DomEvent.disableClickPropagation(container);\n      return container;\n    }\n    /**\r\n     * Sets the query string on the text input\r\n     * @param string the query string\r\n     */\n    ;\n\n    _proto.setQuery = function setQuery(string) {\n      this._input.value = string;\n      return this;\n    };\n\n    _proto._geocodeResult = function _geocodeResult(results, suggest) {\n      if (!suggest && this.options.showUniqueResult && results.length === 1) {\n        this._geocodeResultSelected(results[0]);\n      } else if (results.length > 0) {\n        this._alts.innerHTML = '';\n        this._results = results;\n        L__namespace.DomUtil.removeClass(this._alts, 'leaflet-control-geocoder-alternatives-minimized');\n        L__namespace.DomUtil.addClass(this._container, 'leaflet-control-geocoder-options-open');\n\n        for (var i = 0; i < results.length; i++) {\n          this._alts.appendChild(this._createAlt(results[i], i));\n        }\n      } else {\n        L__namespace.DomUtil.addClass(this._container, 'leaflet-control-geocoder-options-error');\n        L__namespace.DomUtil.addClass(this._errorElement, 'leaflet-control-geocoder-error');\n      }\n    }\n    /**\r\n     * Marks a geocoding result on the map\r\n     * @param result the geocoding result\r\n     */\n    ;\n\n    _proto.markGeocode = function markGeocode(event) {\n      var result = event.geocode;\n\n      this._map.fitBounds(result.bbox);\n\n      if (this._geocodeMarker) {\n        this._map.removeLayer(this._geocodeMarker);\n      }\n\n      this._geocodeMarker = new L__namespace.Marker(result.center).bindPopup(result.html || result.name).addTo(this._map).openPopup();\n      return this;\n    };\n\n    _proto._geocode = function _geocode(suggest) {\n      var _this3 = this;\n\n      var value = this._input.value;\n\n      if (!suggest && value.length < this.options.queryMinLength) {\n        return;\n      }\n\n      var requestCount = ++this._requestCount;\n\n      var cb = function cb(results) {\n        if (requestCount === _this3._requestCount) {\n          var _event = {\n            input: value,\n            results: results\n          };\n\n          _this3.fire(suggest ? 'finishsuggest' : 'finishgeocode', _event);\n\n          _this3._geocodeResult(results, suggest);\n        }\n      };\n\n      this._lastGeocode = value;\n\n      if (!suggest) {\n        this._clearResults();\n      }\n\n      var event = {\n        input: value\n      };\n      this.fire(suggest ? 'startsuggest' : 'startgeocode', event);\n\n      if (suggest) {\n        this.options.geocoder.suggest(value, cb);\n      } else {\n        this.options.geocoder.geocode(value, cb);\n      }\n    };\n\n    _proto._geocodeResultSelected = function _geocodeResultSelected(geocode) {\n      var event = {\n        geocode: geocode\n      };\n      this.fire('markgeocode', event);\n    };\n\n    _proto._toggle = function _toggle() {\n      if (L__namespace.DomUtil.hasClass(this._container, 'leaflet-control-geocoder-expanded')) {\n        this._collapse();\n      } else {\n        this._expand();\n      }\n    };\n\n    _proto._expand = function _expand() {\n      L__namespace.DomUtil.addClass(this._container, 'leaflet-control-geocoder-expanded');\n\n      this._input.select();\n\n      this.fire('expand');\n    };\n\n    _proto._collapse = function _collapse() {\n      L__namespace.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-expanded');\n      L__namespace.DomUtil.addClass(this._alts, 'leaflet-control-geocoder-alternatives-minimized');\n      L__namespace.DomUtil.removeClass(this._errorElement, 'leaflet-control-geocoder-error');\n      L__namespace.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-options-open');\n      L__namespace.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-options-error');\n\n      this._input.blur(); // mobile: keyboard shouldn't stay expanded\n\n\n      this.fire('collapse');\n    };\n\n    _proto._clearResults = function _clearResults() {\n      L__namespace.DomUtil.addClass(this._alts, 'leaflet-control-geocoder-alternatives-minimized');\n      this._selection = null;\n      L__namespace.DomUtil.removeClass(this._errorElement, 'leaflet-control-geocoder-error');\n      L__namespace.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-options-open');\n      L__namespace.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-options-error');\n    };\n\n    _proto._createAlt = function _createAlt(result, index) {\n      var _this4 = this;\n\n      var li = L__namespace.DomUtil.create('li', ''),\n          a = L__namespace.DomUtil.create('a', '', li),\n          icon = this.options.showResultIcons && result.icon ? L__namespace.DomUtil.create('img', '', a) : null,\n          text = result.html ? undefined : document.createTextNode(result.name),\n          mouseDownHandler = function mouseDownHandler(e) {\n        // In some browsers, a click will fire on the map if the control is\n        // collapsed directly after mousedown. To work around this, we\n        // wait until the click is completed, and _then_ collapse the\n        // control. Messy, but this is the workaround I could come up with\n        // for #142.\n        _this4._preventBlurCollapse = true;\n        L__namespace.DomEvent.stop(e);\n\n        _this4._geocodeResultSelected(result);\n\n        L__namespace.DomEvent.on(li, 'click touchend', function () {\n          if (_this4.options.collapsed) {\n            _this4._collapse();\n          } else {\n            _this4._clearResults();\n          }\n        });\n      };\n\n      if (icon) {\n        icon.src = result.icon;\n      }\n\n      li.setAttribute('data-result-index', String(index));\n\n      if (result.html) {\n        a.innerHTML = a.innerHTML + result.html;\n      } else if (text) {\n        a.appendChild(text);\n      } // Use mousedown and not click, since click will fire _after_ blur,\n      // causing the control to have collapsed and removed the items\n      // before the click can fire.\n\n\n      L__namespace.DomEvent.addListener(li, 'mousedown touchstart', mouseDownHandler, this);\n      return li;\n    };\n\n    _proto._keydown = function _keydown(e) {\n      var _this5 = this;\n\n      var select = function select(dir) {\n        if (_this5._selection) {\n          L__namespace.DomUtil.removeClass(_this5._selection, 'leaflet-control-geocoder-selected');\n          _this5._selection = _this5._selection[dir > 0 ? 'nextSibling' : 'previousSibling'];\n        }\n\n        if (!_this5._selection) {\n          _this5._selection = _this5._alts[dir > 0 ? 'firstChild' : 'lastChild'];\n        }\n\n        if (_this5._selection) {\n          L__namespace.DomUtil.addClass(_this5._selection, 'leaflet-control-geocoder-selected');\n        }\n      };\n\n      switch (e.keyCode) {\n        // Escape\n        case 27:\n          if (this.options.collapsed) {\n            this._collapse();\n          } else {\n            this._clearResults();\n          }\n\n          break;\n        // Up\n\n        case 38:\n          select(-1);\n          break;\n        // Up\n\n        case 40:\n          select(1);\n          break;\n        // Enter\n\n        case 13:\n          if (this._selection) {\n            var index = parseInt(this._selection.getAttribute('data-result-index'), 10);\n\n            this._geocodeResultSelected(this._results[index]);\n\n            this._clearResults();\n          } else {\n            this._geocode();\n          }\n\n          break;\n\n        default:\n          return;\n      }\n\n      L__namespace.DomEvent.preventDefault(e);\n    };\n\n    _proto._change = function _change() {\n      var _this6 = this;\n\n      var v = this._input.value;\n\n      if (v !== this._lastGeocode) {\n        clearTimeout(this._suggestTimeout);\n\n        if (v.length >= this.options.suggestMinLength) {\n          this._suggestTimeout = setTimeout(function () {\n            return _this6._geocode(true);\n          }, this.options.suggestTimeout);\n        } else {\n          this._clearResults();\n        }\n      }\n    };\n\n    return GeocoderControl;\n  }(EventedControl);\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link GeocoderControl}\r\n   * @param options the options\r\n   */\n\n  function geocoder(options) {\n    return new GeocoderControl(options);\n  }\n\n  /* @preserve\r\n   * Leaflet Control Geocoder\r\n   * https://github.com/perliedman/leaflet-control-geocoder\r\n   *\r\n   * Copyright (c) 2012 sa3m (https://github.com/sa3m)\r\n   * Copyright (c) 2018 Per Liedman\r\n   * All rights reserved.\r\n   */\n  L__namespace.Util.extend(GeocoderControl, geocoders);\n  L__namespace.Util.extend(L__namespace.Control, {\n    Geocoder: GeocoderControl,\n    geocoder: geocoder\n  });\n\n  exports.Geocoder = GeocoderControl;\n  exports.default = GeocoderControl;\n  exports.geocoder = geocoder;\n  exports.geocoders = geocoders;\n\n  return exports;\n\n}({}, L));\n//# sourceMappingURL=Control.Geocoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGVhZmxldC1jb250cm9sLWdlb2NvZGVyL2Rpc3QvQ29udHJvbC5HZW9jb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZCxjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsYUFBYTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUix3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0Esa0VBQWtFLFFBQVE7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLGdFQUFnRSxRQUFRO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQiw4QkFBOEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLDhCQUE4QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsOENBQThDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQiw0QkFBNEI7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlOztBQUVmLDJDQUEyQyxJQUFJLDJCQUEyQixJQUFJO0FBQzlFO0FBQ0E7QUFDQSxNQUFNLG1DQUFtQyxJQUFJLDJCQUEyQixJQUFJO0FBQzVFO0FBQ0E7QUFDQSxNQUFNLDRDQUE0QyxJQUFJLFVBQVUsSUFBSSxpQ0FBaUMsSUFBSSxVQUFVLElBQUk7QUFDdkg7QUFDQTtBQUNBLE1BQU0sbUNBQW1DLElBQUksVUFBVSxJQUFJLGlDQUFpQyxJQUFJLFVBQVUsSUFBSTtBQUM5RztBQUNBO0FBQ0EsTUFBTSw0Q0FBNEMsSUFBSSxVQUFVLElBQUksYUFBYSxJQUFJLGlDQUFpQyxJQUFJLFVBQVUsSUFBSSxhQUFhLElBQUk7QUFDeko7QUFDQTtBQUNBLE1BQU0sbUNBQW1DLElBQUksVUFBVSxJQUFJLGFBQWEsSUFBSSxnQ0FBZ0MsSUFBSSxVQUFVLElBQUksYUFBYSxJQUFJO0FBQy9JO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsK0JBQStCO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQiwrQkFBK0I7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsNkRBQTZELFFBQVE7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RCxRQUFRO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsV0FBVyxPQUFPLGFBQWE7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RCxXQUFXLE9BQU8sT0FBTyxVQUFVLE9BQU87QUFDbkc7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RCxRQUFRLFFBQVE7QUFDekU7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLHNDQUFzQyxRQUFRO0FBQzlDOztBQUVBLDBCQUEwQixPQUFPO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7OztBQUcxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxHQUFHO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0YWwvLi9ub2RlX21vZHVsZXMvbGVhZmxldC1jb250cm9sLWdlb2NvZGVyL2Rpc3QvQ29udHJvbC5HZW9jb2Rlci5qcz83MGZhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBsZWFmbGV0Q29udHJvbEdlb2NvZGVyID0gKGZ1bmN0aW9uIChleHBvcnRzLCBMKSB7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2UoZSkge1xuICAgIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gICAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChlKSB7XG4gICAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBuWydkZWZhdWx0J10gPSBlO1xuICAgIHJldHVybiBuO1xuICB9XG5cbiAgdmFyIExfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShMKTtcblxuICBmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICAgIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICAgIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG4gIH1cblxuICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cblxuICBmdW5jdGlvbiBnZW9jb2RpbmdQYXJhbXMob3B0aW9ucywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIExfX25hbWVzcGFjZS5VdGlsLmV4dGVuZChwYXJhbXMsIG9wdGlvbnMuZ2VvY29kaW5nUXVlcnlQYXJhbXMpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJldmVyc2VQYXJhbXMob3B0aW9ucywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIExfX25hbWVzcGFjZS5VdGlsLmV4dGVuZChwYXJhbXMsIG9wdGlvbnMucmV2ZXJzZVF1ZXJ5UGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xuXG4gIHZhciBsYXN0Q2FsbGJhY2tJZCA9IDA7IC8vIEFkYXB0ZWQgZnJvbSBoYW5kbGViYXJzLmpzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93eWNhdHMvaGFuZGxlYmFycy5qcy9cblxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cblxuICB2YXIgYmFkQ2hhcnMgPSAvWyY8PlwiJ2BdL2c7XG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xuXG4gIHZhciBwb3NzaWJsZSA9IC9bJjw+XCInYF0vO1xuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cblxuICB2YXIgZXNjYXBlID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjeDI3OycsXG4gICAgJ2AnOiAnJiN4NjA7J1xuICB9O1xuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cblxuICBmdW5jdGlvbiBlc2NhcGVDaGFyKGNocikge1xuICAgIHJldHVybiBlc2NhcGVbY2hyXTtcbiAgfVxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGh0bWxFc2NhcGUoc3RyaW5nKSB7XG4gICAgaWYgKHN0cmluZyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nICsgJyc7XG4gICAgfSAvLyBGb3JjZSBhIHN0cmluZyBjb252ZXJzaW9uIGFzIHRoaXMgd2lsbCBiZSBkb25lIGJ5IHRoZSBhcHBlbmQgcmVnYXJkbGVzcyBhbmRcbiAgICAvLyB0aGUgcmVnZXggdGVzdCB3aWxsIGRvIHRoaXMgdHJhbnNwYXJlbnRseSBiZWhpbmQgdGhlIHNjZW5lcywgY2F1c2luZyBpc3N1ZXMgaWZcbiAgICAvLyBhbiBvYmplY3QncyB0byBzdHJpbmcgaGFzIGVzY2FwZWQgY2hhcmFjdGVycyBpbiBpdC5cblxuXG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG5cbiAgICBpZiAoIXBvc3NpYmxlLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoYmFkQ2hhcnMsIGVzY2FwZUNoYXIpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGpzb25wKHVybCwgcGFyYW1zLCBjYWxsYmFjaywgY29udGV4dCwganNvbnBQYXJhbSkge1xuICAgIHZhciBjYWxsYmFja0lkID0gJ19sX2dlb2NvZGVyXycgKyBsYXN0Q2FsbGJhY2tJZCsrO1xuICAgIHBhcmFtc1tqc29ucFBhcmFtIHx8ICdjYWxsYmFjayddID0gY2FsbGJhY2tJZDtcbiAgICB3aW5kb3dbY2FsbGJhY2tJZF0gPSBMX19uYW1lc3BhY2UuVXRpbC5iaW5kKGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICBzY3JpcHQuc3JjID0gdXJsICsgZ2V0UGFyYW1TdHJpbmcocGFyYW1zKTtcbiAgICBzY3JpcHQuaWQgPSBjYWxsYmFja0lkO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgfVxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cblxuICBmdW5jdGlvbiBnZXRKU09OKHVybCwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgIHZhciB4bWxIdHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICB4bWxIdHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh4bWxIdHRwLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWVzc2FnZTtcblxuICAgICAgaWYgKHhtbEh0dHAuc3RhdHVzICE9PSAyMDAgJiYgeG1sSHR0cC5zdGF0dXMgIT09IDMwNCkge1xuICAgICAgICBtZXNzYWdlID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB4bWxIdHRwLnJlc3BvbnNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBJRSBkb2Vzbid0IHBhcnNlIEpTT04gcmVzcG9uc2VzIGV2ZW4gd2l0aCByZXNwb25zZVR5cGU6ICdqc29uJy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtZXNzYWdlID0gSlNPTi5wYXJzZSh4bWxIdHRwLnJlc3BvbnNlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIE5vdCBhIEpTT04gcmVzcG9uc2VcbiAgICAgICAgICBtZXNzYWdlID0geG1sSHR0cC5yZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZSA9IHhtbEh0dHAucmVzcG9uc2U7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG1lc3NhZ2UpO1xuICAgIH07XG5cbiAgICB4bWxIdHRwLm9wZW4oJ0dFVCcsIHVybCArIGdldFBhcmFtU3RyaW5nKHBhcmFtcyksIHRydWUpO1xuICAgIHhtbEh0dHAucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgIHhtbEh0dHAuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICB4bWxIdHRwLnNlbmQobnVsbCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gdGVtcGxhdGUoc3RyLCBkYXRhKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHsgKihbXFx3X10rKSAqXFx9L2csIGZ1bmN0aW9uIChzdHIsIGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gZGF0YVtrZXldO1xuXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZShkYXRhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGh0bWxFc2NhcGUodmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldFBhcmFtU3RyaW5nKG9iaiwgZXhpc3RpbmdVcmwsIHVwcGVyY2FzZSkge1xuICAgIHZhciBwYXJhbXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICB2YXIga2V5ID0gZW5jb2RlVVJJQ29tcG9uZW50KHVwcGVyY2FzZSA/IGkudG9VcHBlckNhc2UoKSA6IGkpO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2ldO1xuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKGtleSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcodmFsdWUpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgcGFyYW1zLnB1c2goa2V5ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlW2pdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKCFleGlzdGluZ1VybCB8fCBleGlzdGluZ1VybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHBhcmFtcy5qb2luKCcmJyk7XG4gIH1cblxuICAvKipcclxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgW0FyY0dJUyBnZW9jb2Rlcl0oaHR0cHM6Ly9kZXZlbG9wZXJzLmFyY2dpcy5jb20vZmVhdHVyZXMvZ2VvY29kaW5nLylcclxuICAgKi9cblxuICB2YXIgQXJjR2lzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcmNHaXMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBzZXJ2aWNlVXJsOiAnaHR0cHM6Ly9nZW9jb2RlLmFyY2dpcy5jb20vYXJjZ2lzL3Jlc3Qvc2VydmljZXMvV29ybGQvR2VvY29kZVNlcnZlcicsXG4gICAgICAgIGFwaUtleTogJydcbiAgICAgIH07XG4gICAgICBMX19uYW1lc3BhY2UuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBBcmNHaXMucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmdlb2NvZGUgPSBmdW5jdGlvbiBnZW9jb2RlKHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgICAgdmFyIHBhcmFtcyA9IGdlb2NvZGluZ1BhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgdG9rZW46IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICAgIFNpbmdsZUxpbmU6IHF1ZXJ5LFxuICAgICAgICBvdXRGaWVsZHM6ICdBZGRyX1R5cGUnLFxuICAgICAgICBmb3JTdG9yYWdlOiBmYWxzZSxcbiAgICAgICAgbWF4TG9jYXRpb25zOiAxMCxcbiAgICAgICAgZjogJ2pzb24nXG4gICAgICB9KTtcbiAgICAgIGdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwgKyAnL2ZpbmRBZGRyZXNzQ2FuZGlkYXRlcycsIHBhcmFtcywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBpZiAoZGF0YS5jYW5kaWRhdGVzICYmIGRhdGEuY2FuZGlkYXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBkYXRhLmNhbmRpZGF0ZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbG9jID0gZGF0YS5jYW5kaWRhdGVzW2ldO1xuICAgICAgICAgICAgdmFyIGxhdExuZyA9IExfX25hbWVzcGFjZS5sYXRMbmcobG9jLmxvY2F0aW9uLnksIGxvYy5sb2NhdGlvbi54KTtcbiAgICAgICAgICAgIHZhciBsYXRMbmdCb3VuZHMgPSBMX19uYW1lc3BhY2UubGF0TG5nQm91bmRzKExfX25hbWVzcGFjZS5sYXRMbmcobG9jLmV4dGVudC55bWF4LCBsb2MuZXh0ZW50LnhtYXgpLCBMX19uYW1lc3BhY2UubGF0TG5nKGxvYy5leHRlbnQueW1pbiwgbG9jLmV4dGVudC54bWluKSk7XG4gICAgICAgICAgICByZXN1bHRzW2ldID0ge1xuICAgICAgICAgICAgICBuYW1lOiBsb2MuYWRkcmVzcyxcbiAgICAgICAgICAgICAgYmJveDogbGF0TG5nQm91bmRzLFxuICAgICAgICAgICAgICBjZW50ZXI6IGxhdExuZ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdHMpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9wcm90by5zdWdnZXN0ID0gZnVuY3Rpb24gc3VnZ2VzdChxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKGxvY2F0aW9uLCBzY2FsZSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBwYXJhbXMgPSByZXZlcnNlUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24ubG5nICsgJywnICsgbG9jYXRpb24ubGF0LFxuICAgICAgICBkaXN0YW5jZTogMTAwLFxuICAgICAgICBmOiAnanNvbidcbiAgICAgIH0pO1xuICAgICAgZ2V0SlNPTih0aGlzLm9wdGlvbnMuc2VydmljZVVybCArICcvcmV2ZXJzZUdlb2NvZGUnLCBwYXJhbXMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZiAoZGF0YSAmJiAhZGF0YS5lcnJvcikge1xuICAgICAgICAgIHZhciBjZW50ZXIgPSBMX19uYW1lc3BhY2UubGF0TG5nKGRhdGEubG9jYXRpb24ueSwgZGF0YS5sb2NhdGlvbi54KTtcbiAgICAgICAgICB2YXIgYmJveCA9IExfX25hbWVzcGFjZS5sYXRMbmdCb3VuZHMoY2VudGVyLCBjZW50ZXIpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IGRhdGEuYWRkcmVzcy5NYXRjaF9hZGRyLFxuICAgICAgICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICAgICAgICBiYm94OiBiYm94XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEFyY0dpcztcbiAgfSgpO1xuICAvKipcclxuICAgKiBbQ2xhc3MgZmFjdG9yeSBtZXRob2RdKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9yZWZlcmVuY2UuaHRtbCNjbGFzcy1jbGFzcy1mYWN0b3JpZXMpIGZvciB7QGxpbmsgQXJjR2lzfVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gYXJjZ2lzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEFyY0dpcyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxyXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBbQmluZyBMb2NhdGlvbnMgQVBJXShodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9iaW5nbWFwcy9yZXN0LXNlcnZpY2VzL2xvY2F0aW9ucy8pXHJcbiAgICovXG5cbiAgdmFyIEJpbmcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJpbmcob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBzZXJ2aWNlVXJsOiAnaHR0cHM6Ly9kZXYudmlydHVhbGVhcnRoLm5ldC9SRVNUL3YxL0xvY2F0aW9ucydcbiAgICAgIH07XG4gICAgICBMX19uYW1lc3BhY2UuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBCaW5nLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5nZW9jb2RlID0gZnVuY3Rpb24gZ2VvY29kZShxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBwYXJhbXMgPSBnZW9jb2RpbmdQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAga2V5OiB0aGlzLm9wdGlvbnMuYXBpS2V5XG4gICAgICB9KTtcbiAgICAgIGpzb25wKHRoaXMub3B0aW9ucy5hcGlLZXksIHBhcmFtcywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBpZiAoZGF0YS5yZXNvdXJjZVNldHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSBkYXRhLnJlc291cmNlU2V0c1swXS5yZXNvdXJjZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciByZXNvdXJjZSA9IGRhdGEucmVzb3VyY2VTZXRzWzBdLnJlc291cmNlc1tpXSxcbiAgICAgICAgICAgICAgICBiYm94ID0gcmVzb3VyY2UuYmJveDtcbiAgICAgICAgICAgIHJlc3VsdHNbaV0gPSB7XG4gICAgICAgICAgICAgIG5hbWU6IHJlc291cmNlLm5hbWUsXG4gICAgICAgICAgICAgIGJib3g6IExfX25hbWVzcGFjZS5sYXRMbmdCb3VuZHMoW2Jib3hbMF0sIGJib3hbMV1dLCBbYmJveFsyXSwgYmJveFszXV0pLFxuICAgICAgICAgICAgICBjZW50ZXI6IExfX25hbWVzcGFjZS5sYXRMbmcocmVzb3VyY2UucG9pbnQuY29vcmRpbmF0ZXMpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0cyk7XG4gICAgICB9LCB0aGlzLCAnanNvbnAnKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKGxvY2F0aW9uLCBzY2FsZSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBwYXJhbXMgPSByZXZlcnNlUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgICBrZXk6IHRoaXMub3B0aW9ucy5hcGlLZXlcbiAgICAgIH0pO1xuICAgICAganNvbnAodGhpcy5vcHRpb25zLnNlcnZpY2VVcmwgKyBsb2NhdGlvbi5sYXQgKyAnLCcgKyBsb2NhdGlvbi5sbmcsIHBhcmFtcywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gZGF0YS5yZXNvdXJjZVNldHNbMF0ucmVzb3VyY2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIHJlc291cmNlID0gZGF0YS5yZXNvdXJjZVNldHNbMF0ucmVzb3VyY2VzW2ldLFxuICAgICAgICAgICAgICBiYm94ID0gcmVzb3VyY2UuYmJveDtcbiAgICAgICAgICByZXN1bHRzW2ldID0ge1xuICAgICAgICAgICAgbmFtZTogcmVzb3VyY2UubmFtZSxcbiAgICAgICAgICAgIGJib3g6IExfX25hbWVzcGFjZS5sYXRMbmdCb3VuZHMoW2Jib3hbMF0sIGJib3hbMV1dLCBbYmJveFsyXSwgYmJveFszXV0pLFxuICAgICAgICAgICAgY2VudGVyOiBMX19uYW1lc3BhY2UubGF0TG5nKHJlc291cmNlLnBvaW50LmNvb3JkaW5hdGVzKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdHMpO1xuICAgICAgfSwgdGhpcywgJ2pzb25wJyk7XG4gICAgfTtcblxuICAgIHJldHVybiBCaW5nO1xuICB9KCk7XG4gIC8qKlxyXG4gICAqIFtDbGFzcyBmYWN0b3J5IG1ldGhvZF0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2NsYXNzLWNsYXNzLWZhY3RvcmllcykgZm9yIHtAbGluayBCaW5nfVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gYmluZyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBCaW5nKG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIEdvb2dsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR29vZ2xlKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgc2VydmljZVVybDogJ2h0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9nZW9jb2RlL2pzb24nXG4gICAgICB9O1xuICAgICAgTF9fbmFtZXNwYWNlLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gR29vZ2xlLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5nZW9jb2RlID0gZnVuY3Rpb24gZ2VvY29kZShxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBwYXJhbXMgPSBnZW9jb2RpbmdQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICAgIGtleTogdGhpcy5vcHRpb25zLmFwaUtleSxcbiAgICAgICAgYWRkcmVzczogcXVlcnlcbiAgICAgIH0pO1xuICAgICAgZ2V0SlNPTih0aGlzLm9wdGlvbnMuc2VydmljZVVybCwgcGFyYW1zLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGlmIChkYXRhLnJlc3VsdHMgJiYgZGF0YS5yZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGRhdGEucmVzdWx0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsb2MgPSBkYXRhLnJlc3VsdHNbaV07XG4gICAgICAgICAgICB2YXIgbGF0TG5nID0gTF9fbmFtZXNwYWNlLmxhdExuZyhsb2MuZ2VvbWV0cnkubG9jYXRpb24pO1xuICAgICAgICAgICAgdmFyIGxhdExuZ0JvdW5kcyA9IExfX25hbWVzcGFjZS5sYXRMbmdCb3VuZHMoTF9fbmFtZXNwYWNlLmxhdExuZyhsb2MuZ2VvbWV0cnkudmlld3BvcnQubm9ydGhlYXN0KSwgTF9fbmFtZXNwYWNlLmxhdExuZyhsb2MuZ2VvbWV0cnkudmlld3BvcnQuc291dGh3ZXN0KSk7XG4gICAgICAgICAgICByZXN1bHRzW2ldID0ge1xuICAgICAgICAgICAgICBuYW1lOiBsb2MuZm9ybWF0dGVkX2FkZHJlc3MsXG4gICAgICAgICAgICAgIGJib3g6IGxhdExuZ0JvdW5kcyxcbiAgICAgICAgICAgICAgY2VudGVyOiBsYXRMbmcsXG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IGxvYy5hZGRyZXNzX2NvbXBvbmVudHNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCByZXN1bHRzKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UobG9jYXRpb24sIHNjYWxlLCBjYiwgY29udGV4dCkge1xuICAgICAgdmFyIHBhcmFtcyA9IHJldmVyc2VQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICAgIGtleTogdGhpcy5vcHRpb25zLmFwaUtleSxcbiAgICAgICAgbGF0bG5nOiBsb2NhdGlvbi5sYXQgKyAnLCcgKyBsb2NhdGlvbi5sbmdcbiAgICAgIH0pO1xuICAgICAgZ2V0SlNPTih0aGlzLm9wdGlvbnMuc2VydmljZVVybCwgcGFyYW1zLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGlmIChkYXRhLnJlc3VsdHMgJiYgZGF0YS5yZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGRhdGEucmVzdWx0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsb2MgPSBkYXRhLnJlc3VsdHNbaV07XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gTF9fbmFtZXNwYWNlLmxhdExuZyhsb2MuZ2VvbWV0cnkubG9jYXRpb24pO1xuICAgICAgICAgICAgdmFyIGJib3ggPSBMX19uYW1lc3BhY2UubGF0TG5nQm91bmRzKExfX25hbWVzcGFjZS5sYXRMbmcobG9jLmdlb21ldHJ5LnZpZXdwb3J0Lm5vcnRoZWFzdCksIExfX25hbWVzcGFjZS5sYXRMbmcobG9jLmdlb21ldHJ5LnZpZXdwb3J0LnNvdXRod2VzdCkpO1xuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHtcbiAgICAgICAgICAgICAgbmFtZTogbG9jLmZvcm1hdHRlZF9hZGRyZXNzLFxuICAgICAgICAgICAgICBiYm94OiBiYm94LFxuICAgICAgICAgICAgICBjZW50ZXI6IGNlbnRlcixcbiAgICAgICAgICAgICAgcHJvcGVydGllczogbG9jLmFkZHJlc3NfY29tcG9uZW50c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdHMpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBHb29nbGU7XG4gIH0oKTtcbiAgLyoqXHJcbiAgICogW0NsYXNzIGZhY3RvcnkgbWV0aG9kXShodHRwczovL2xlYWZsZXRqcy5jb20vcmVmZXJlbmNlLmh0bWwjY2xhc3MtY2xhc3MtZmFjdG9yaWVzKSBmb3Ige0BsaW5rIEdvb2dsZX1cclxuICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9uc1xyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdvb2dsZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBHb29nbGUob3B0aW9ucyk7XG4gIH1cblxuICAvKipcclxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgW0hFUkUgR2VvY29kZXIgQVBJXShodHRwczovL2RldmVsb3Blci5oZXJlLmNvbS9kb2N1bWVudGF0aW9uL2dlb2NvZGVyL3RvcGljcy9pbnRyb2R1Y3Rpb24uaHRtbClcclxuICAgKi9cblxuICB2YXIgSEVSRSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSEVSRShvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgIHNlcnZpY2VVcmw6ICdodHRwczovL2dlb2NvZGVyLmFwaS5oZXJlLmNvbS82LjIvJyxcbiAgICAgICAgYXBwX2lkOiAnJyxcbiAgICAgICAgYXBwX2NvZGU6ICcnLFxuICAgICAgICBhcGlLZXk6ICcnLFxuICAgICAgICBtYXhSZXN1bHRzOiA1XG4gICAgICB9O1xuICAgICAgTF9fbmFtZXNwYWNlLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLmFwaUtleSkgdGhyb3cgRXJyb3IoJ2FwaUtleSBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgYXBwX2lkL2FwcF9jb2RlIGluc3RlYWQhJyk7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IEhFUkUucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmdlb2NvZGUgPSBmdW5jdGlvbiBnZW9jb2RlKHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgICAgdmFyIHBhcmFtcyA9IGdlb2NvZGluZ1BhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgc2VhcmNodGV4dDogcXVlcnksXG4gICAgICAgIGdlbjogOSxcbiAgICAgICAgYXBwX2lkOiB0aGlzLm9wdGlvbnMuYXBwX2lkLFxuICAgICAgICBhcHBfY29kZTogdGhpcy5vcHRpb25zLmFwcF9jb2RlLFxuICAgICAgICBqc29uYXR0cmlidXRlczogMSxcbiAgICAgICAgbWF4cmVzdWx0czogdGhpcy5vcHRpb25zLm1heFJlc3VsdHNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5nZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgJ2dlb2NvZGUuanNvbicsIHBhcmFtcywgY2IsIGNvbnRleHQpO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UobG9jYXRpb24sIHNjYWxlLCBjYiwgY29udGV4dCkge1xuICAgICAgdmFyIHByb3ggPSBsb2NhdGlvbi5sYXQgKyAnLCcgKyBsb2NhdGlvbi5sbmc7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmV2ZXJzZUdlb2NvZGVQcm94UmFkaXVzKSB7XG4gICAgICAgIHByb3ggKz0gJywnICsgdGhpcy5vcHRpb25zLnJldmVyc2VHZW9jb2RlUHJveFJhZGl1cztcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmFtcyA9IHJldmVyc2VQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICAgIHByb3g6IHByb3gsXG4gICAgICAgIG1vZGU6ICdyZXRyaWV2ZUFkZHJlc3NlcycsXG4gICAgICAgIGFwcF9pZDogdGhpcy5vcHRpb25zLmFwcF9pZCxcbiAgICAgICAgYXBwX2NvZGU6IHRoaXMub3B0aW9ucy5hcHBfY29kZSxcbiAgICAgICAgZ2VuOiA5LFxuICAgICAgICBqc29uYXR0cmlidXRlczogMSxcbiAgICAgICAgbWF4cmVzdWx0czogdGhpcy5vcHRpb25zLm1heFJlc3VsdHNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5nZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgJ3JldmVyc2VnZW9jb2RlLmpzb24nLCBwYXJhbXMsIGNiLCBjb250ZXh0KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmdldEpTT04gPSBmdW5jdGlvbiBnZXRKU09OJDEodXJsLCBwYXJhbXMsIGNiLCBjb250ZXh0KSB7XG4gICAgICBnZXRKU09OKHVybCwgcGFyYW1zLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGlmIChkYXRhLnJlc3BvbnNlLnZpZXcgJiYgZGF0YS5yZXNwb25zZS52aWV3Lmxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGRhdGEucmVzcG9uc2Uudmlld1swXS5yZXN1bHQubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbG9jID0gZGF0YS5yZXNwb25zZS52aWV3WzBdLnJlc3VsdFtpXS5sb2NhdGlvbjtcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSBMX19uYW1lc3BhY2UubGF0TG5nKGxvYy5kaXNwbGF5UG9zaXRpb24ubGF0aXR1ZGUsIGxvYy5kaXNwbGF5UG9zaXRpb24ubG9uZ2l0dWRlKTtcbiAgICAgICAgICAgIHZhciBiYm94ID0gTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhMX19uYW1lc3BhY2UubGF0TG5nKGxvYy5tYXBWaWV3LnRvcExlZnQubGF0aXR1ZGUsIGxvYy5tYXBWaWV3LnRvcExlZnQubG9uZ2l0dWRlKSwgTF9fbmFtZXNwYWNlLmxhdExuZyhsb2MubWFwVmlldy5ib3R0b21SaWdodC5sYXRpdHVkZSwgbG9jLm1hcFZpZXcuYm90dG9tUmlnaHQubG9uZ2l0dWRlKSk7XG4gICAgICAgICAgICByZXN1bHRzW2ldID0ge1xuICAgICAgICAgICAgICBuYW1lOiBsb2MuYWRkcmVzcy5sYWJlbCxcbiAgICAgICAgICAgICAgcHJvcGVydGllczogbG9jLmFkZHJlc3MsXG4gICAgICAgICAgICAgIGJib3g6IGJib3gsXG4gICAgICAgICAgICAgIGNlbnRlcjogY2VudGVyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0cyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEhFUkU7XG4gIH0oKTtcbiAgLyoqXHJcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIG5ldyBbSEVSRSBHZW9jb2RlciBBUEldKGh0dHBzOi8vZGV2ZWxvcGVyLmhlcmUuY29tL2RvY3VtZW50YXRpb24vZ2VvY29kaW5nLXNlYXJjaC1hcGkvYXBpLXJlZmVyZW5jZS1zd2FnZ2VyLmh0bWwpXHJcbiAgICovXG5cbiAgdmFyIEhFUkV2MiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSEVSRXYyKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgc2VydmljZVVybDogJ2h0dHBzOi8vZ2VvY29kZS5zZWFyY2guaGVyZWFwaS5jb20vdjEnLFxuICAgICAgICBhcGlLZXk6ICcnLFxuICAgICAgICBhcHBfaWQ6ICcnLFxuICAgICAgICBhcHBfY29kZTogJycsXG4gICAgICAgIG1heFJlc3VsdHM6IDEwXG4gICAgICB9O1xuICAgICAgTF9fbmFtZXNwYWNlLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvMiA9IEhFUkV2Mi5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8yLmdlb2NvZGUgPSBmdW5jdGlvbiBnZW9jb2RlKHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgICAgdmFyIHBhcmFtcyA9IGdlb2NvZGluZ1BhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgcTogcXVlcnksXG4gICAgICAgIGFwaUtleTogdGhpcy5vcHRpb25zLmFwaUtleSxcbiAgICAgICAgbGltaXQ6IHRoaXMub3B0aW9ucy5tYXhSZXN1bHRzXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFwYXJhbXMuYXQgJiYgIXBhcmFtc1tcImluXCJdKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdhdCAvIGluIHBhcmFtZXRlcnMgbm90IGZvdW5kLiBQbGVhc2UgZGVmaW5lIGNvb3JkaW5hdGVzIChhdD1sYXRpdHVkZSxsb25naXR1ZGUpIG9yIG90aGVyIChpbikgaW4geW91ciBnZW9jb2RpbmdRdWVyeVBhcmFtcy4nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5nZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgJy9kaXNjb3ZlcicsIHBhcmFtcywgY2IsIGNvbnRleHQpO1xuICAgIH07XG5cbiAgICBfcHJvdG8yLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKGxvY2F0aW9uLCBzY2FsZSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBwYXJhbXMgPSByZXZlcnNlUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgICBhdDogbG9jYXRpb24ubGF0ICsgJywnICsgbG9jYXRpb24ubG5nLFxuICAgICAgICBsaW1pdDogdGhpcy5vcHRpb25zLnJldmVyc2VHZW9jb2RlUHJveFJhZGl1cyxcbiAgICAgICAgYXBpS2V5OiB0aGlzLm9wdGlvbnMuYXBpS2V5XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZ2V0SlNPTih0aGlzLm9wdGlvbnMuc2VydmljZVVybCArICcvcmV2Z2VvY29kZScsIHBhcmFtcywgY2IsIGNvbnRleHQpO1xuICAgIH07XG5cbiAgICBfcHJvdG8yLmdldEpTT04gPSBmdW5jdGlvbiBnZXRKU09OJDEodXJsLCBwYXJhbXMsIGNiLCBjb250ZXh0KSB7XG4gICAgICBnZXRKU09OKHVybCwgcGFyYW1zLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGlmIChkYXRhLml0ZW1zICYmIGRhdGEuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gZGF0YS5pdGVtcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gZGF0YS5pdGVtc1tpXTtcbiAgICAgICAgICAgIHZhciBsYXRMbmcgPSBMX19uYW1lc3BhY2UubGF0TG5nKGl0ZW0ucG9zaXRpb24ubGF0LCBpdGVtLnBvc2l0aW9uLmxuZyk7XG4gICAgICAgICAgICB2YXIgYmJveCA9IHZvaWQgMDtcblxuICAgICAgICAgICAgaWYgKGl0ZW0ubWFwVmlldykge1xuICAgICAgICAgICAgICBiYm94ID0gTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhMX19uYW1lc3BhY2UubGF0TG5nKGl0ZW0ubWFwVmlldy5zb3V0aCwgaXRlbS5tYXBWaWV3Lndlc3QpLCBMX19uYW1lc3BhY2UubGF0TG5nKGl0ZW0ubWFwVmlldy5ub3J0aCwgaXRlbS5tYXBWaWV3LmVhc3QpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFVzaW5nIG9ubHkgcG9zaXRpb24gd2hlbiBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgICAgYmJveCA9IExfX25hbWVzcGFjZS5sYXRMbmdCb3VuZHMoTF9fbmFtZXNwYWNlLmxhdExuZyhpdGVtLnBvc2l0aW9uLmxhdCwgaXRlbS5wb3NpdGlvbi5sbmcpLCBMX19uYW1lc3BhY2UubGF0TG5nKGl0ZW0ucG9zaXRpb24ubGF0LCBpdGVtLnBvc2l0aW9uLmxuZykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRzW2ldID0ge1xuICAgICAgICAgICAgICBuYW1lOiBpdGVtLmFkZHJlc3MubGFiZWwsXG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IGl0ZW0uYWRkcmVzcyxcbiAgICAgICAgICAgICAgYmJveDogYmJveCxcbiAgICAgICAgICAgICAgY2VudGVyOiBsYXRMbmdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCByZXN1bHRzKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gSEVSRXYyO1xuICB9KCk7XG4gIC8qKlxyXG4gICAqIFtDbGFzcyBmYWN0b3J5IG1ldGhvZF0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2NsYXNzLWNsYXNzLWZhY3RvcmllcykgZm9yIHtAbGluayBIRVJFfVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gaGVyZShvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuYXBpS2V5KSB7XG4gICAgICByZXR1cm4gbmV3IEhFUkV2MihvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBIRVJFKG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxyXG4gICAqIFBhcnNlcyBiYXNpYyBsYXRpdHVkZS9sb25naXR1ZGUgc3RyaW5ncyBzdWNoIGFzIGAnNTAuMDY3NzMgMTQuMzc3NDInYCwgYCdONTAuMDY3NzMgVzE0LjM3NzQyJ2AsIGAnUyA1MMKwIDA0LjA2NCBFIDAxNMKwIDIyLjY0NSdgLCBvciBgJ1MgNTDCsCA04oCyIDAzLjgyOOKAsywgVyAxNMKwIDIy4oCyIDM4LjcxMuKAsydgXHJcbiAgICogQHBhcmFtIHF1ZXJ5IHRoZSBsYXRpdHVkZS9sb25naXR1ZGUgc3RyaW5nIHRvIHBhcnNlXHJcbiAgICogQHJldHVybnMgdGhlIHBhcnNlZCBsYXRpdHVkZS9sb25naXR1ZGVcclxuICAgKi9cblxuICBmdW5jdGlvbiBwYXJzZUxhdExuZyhxdWVyeSkge1xuICAgIHZhciBtYXRjaDsgLy8gcmVnZXggZnJvbSBodHRwczovL2dpdGh1Yi5jb20vb3BlbnN0cmVldG1hcC9vcGVuc3RyZWV0bWFwLXdlYnNpdGUvYmxvYi9tYXN0ZXIvYXBwL2NvbnRyb2xsZXJzL2dlb2NvZGVyX2NvbnRyb2xsZXIucmJcblxuICAgIGlmIChtYXRjaCA9IHF1ZXJ5Lm1hdGNoKC9eKFtOU10pXFxzKihcXGR7MSwzfSg/OlxcLlxcZCopPylcXFcqKFtFV10pXFxzKihcXGR7MSwzfSg/OlxcLlxcZCopPykkLykpIHtcbiAgICAgIC8vIFtOU0VXXSBkZWNpbWFsIGRlZ3JlZXNcbiAgICAgIHJldHVybiBMX19uYW1lc3BhY2UubGF0TG5nKCgvTi9pLnRlc3QobWF0Y2hbMV0pID8gMSA6IC0xKSAqICttYXRjaFsyXSwgKC9FL2kudGVzdChtYXRjaFszXSkgPyAxIDogLTEpICogK21hdGNoWzRdKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoID0gcXVlcnkubWF0Y2goL14oXFxkezEsM30oPzpcXC5cXGQqKT8pXFxzKihbTlNdKVxcVyooXFxkezEsM30oPzpcXC5cXGQqKT8pXFxzKihbRVddKSQvKSkge1xuICAgICAgLy8gZGVjaW1hbCBkZWdyZWVzIFtOU0VXXVxuICAgICAgcmV0dXJuIExfX25hbWVzcGFjZS5sYXRMbmcoKC9OL2kudGVzdChtYXRjaFsyXSkgPyAxIDogLTEpICogK21hdGNoWzFdLCAoL0UvaS50ZXN0KG1hdGNoWzRdKSA/IDEgOiAtMSkgKiArbWF0Y2hbM10pO1xuICAgIH0gZWxzZSBpZiAobWF0Y2ggPSBxdWVyeS5tYXRjaCgvXihbTlNdKVxccyooXFxkezEsM30pwrA/XFxzKihcXGR7MSwzfSg/OlxcLlxcZCopPyk/WyfigLJdP1xcVyooW0VXXSlcXHMqKFxcZHsxLDN9KcKwP1xccyooXFxkezEsM30oPzpcXC5cXGQqKT8pP1sn4oCyXT8kLykpIHtcbiAgICAgIC8vIFtOU0VXXSBkZWdyZWVzLCBkZWNpbWFsIG1pbnV0ZXNcbiAgICAgIHJldHVybiBMX19uYW1lc3BhY2UubGF0TG5nKCgvTi9pLnRlc3QobWF0Y2hbMV0pID8gMSA6IC0xKSAqICgrbWF0Y2hbMl0gKyArbWF0Y2hbM10gLyA2MCksICgvRS9pLnRlc3QobWF0Y2hbNF0pID8gMSA6IC0xKSAqICgrbWF0Y2hbNV0gKyArbWF0Y2hbNl0gLyA2MCkpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2ggPSBxdWVyeS5tYXRjaCgvXihcXGR7MSwzfSnCsD9cXHMqKFxcZHsxLDN9KD86XFwuXFxkKik/KT9bJ+KAsl0/XFxzKihbTlNdKVxcVyooXFxkezEsM30pwrA/XFxzKihcXGR7MSwzfSg/OlxcLlxcZCopPyk/WyfigLJdP1xccyooW0VXXSkkLykpIHtcbiAgICAgIC8vIGRlZ3JlZXMsIGRlY2ltYWwgbWludXRlcyBbTlNFV11cbiAgICAgIHJldHVybiBMX19uYW1lc3BhY2UubGF0TG5nKCgvTi9pLnRlc3QobWF0Y2hbM10pID8gMSA6IC0xKSAqICgrbWF0Y2hbMV0gKyArbWF0Y2hbMl0gLyA2MCksICgvRS9pLnRlc3QobWF0Y2hbNl0pID8gMSA6IC0xKSAqICgrbWF0Y2hbNF0gKyArbWF0Y2hbNV0gLyA2MCkpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2ggPSBxdWVyeS5tYXRjaCgvXihbTlNdKVxccyooXFxkezEsM30pwrA/XFxzKihcXGR7MSwyfSlbJ+KAsl0/XFxzKihcXGR7MSwzfSg/OlxcLlxcZCopPyk/W1wi4oCzXT9cXFcqKFtFV10pXFxzKihcXGR7MSwzfSnCsD9cXHMqKFxcZHsxLDJ9KVsn4oCyXT9cXHMqKFxcZHsxLDN9KD86XFwuXFxkKik/KT9bXCLigLNdPyQvKSkge1xuICAgICAgLy8gW05TRVddIGRlZ3JlZXMsIG1pbnV0ZXMsIGRlY2ltYWwgc2Vjb25kc1xuICAgICAgcmV0dXJuIExfX25hbWVzcGFjZS5sYXRMbmcoKC9OL2kudGVzdChtYXRjaFsxXSkgPyAxIDogLTEpICogKCttYXRjaFsyXSArICttYXRjaFszXSAvIDYwICsgK21hdGNoWzRdIC8gMzYwMCksICgvRS9pLnRlc3QobWF0Y2hbNV0pID8gMSA6IC0xKSAqICgrbWF0Y2hbNl0gKyArbWF0Y2hbN10gLyA2MCArICttYXRjaFs4XSAvIDM2MDApKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoID0gcXVlcnkubWF0Y2goL14oXFxkezEsM30pwrA/XFxzKihcXGR7MSwyfSlbJ+KAsl0/XFxzKihcXGR7MSwzfSg/OlxcLlxcZCopPyk/W1wi4oCzXVxccyooW05TXSlcXFcqKFxcZHsxLDN9KcKwP1xccyooXFxkezEsMn0pWyfigLJdP1xccyooXFxkezEsM30oPzpcXC5cXGQqKT8pP1tcIuKAs10/XFxzKihbRVddKSQvKSkge1xuICAgICAgLy8gZGVncmVlcywgbWludXRlcywgZGVjaW1hbCBzZWNvbmRzIFtOU0VXXVxuICAgICAgcmV0dXJuIExfX25hbWVzcGFjZS5sYXRMbmcoKC9OL2kudGVzdChtYXRjaFs0XSkgPyAxIDogLTEpICogKCttYXRjaFsxXSArICttYXRjaFsyXSAvIDYwICsgK21hdGNoWzNdIC8gMzYwMCksICgvRS9pLnRlc3QobWF0Y2hbOF0pID8gMSA6IC0xKSAqICgrbWF0Y2hbNV0gKyArbWF0Y2hbNl0gLyA2MCArICttYXRjaFs3XSAvIDM2MDApKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoID0gcXVlcnkubWF0Y2goL15cXHMqKFsrLV0/XFxkKyg/OlxcLlxcZCopPylcXHMqW1xccyxdXFxzKihbKy1dP1xcZCsoPzpcXC5cXGQqKT8pXFxzKiQvKSkge1xuICAgICAgcmV0dXJuIExfX25hbWVzcGFjZS5sYXRMbmcoK21hdGNoWzFdLCArbWF0Y2hbMl0pO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBQYXJzZXMgYmFzaWMgbGF0aXR1ZGUvbG9uZ2l0dWRlIHN0cmluZ3Mgc3VjaCBhcyBgJzUwLjA2NzczIDE0LjM3NzQyJ2AsIGAnTjUwLjA2NzczIFcxNC4zNzc0MidgLCBgJ1MgNTDCsCAwNC4wNjQgRSAwMTTCsCAyMi42NDUnYCwgb3IgYCdTIDUwwrAgNOKAsiAwMy44MjjigLMsIFcgMTTCsCAyMuKAsiAzOC43MTLigLMnYFxyXG4gICAqL1xuXG4gIHZhciBMYXRMbmcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExhdExuZyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgIG5leHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgc2l6ZUluTWV0ZXJzOiAxMDAwMFxuICAgICAgfTtcbiAgICAgIExfX25hbWVzcGFjZS5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IExhdExuZy5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZ2VvY29kZSA9IGZ1bmN0aW9uIGdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KSB7XG4gICAgICB2YXIgY2VudGVyID0gcGFyc2VMYXRMbmcocXVlcnkpO1xuXG4gICAgICBpZiAoY2VudGVyKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW3tcbiAgICAgICAgICBuYW1lOiBxdWVyeSxcbiAgICAgICAgICBjZW50ZXI6IGNlbnRlcixcbiAgICAgICAgICBiYm94OiBjZW50ZXIudG9Cb3VuZHModGhpcy5vcHRpb25zLnNpemVJbk1ldGVycylcbiAgICAgICAgfV07XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0cyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5uZXh0KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5uZXh0Lmdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIExhdExuZztcbiAgfSgpO1xuICAvKipcclxuICAgKiBbQ2xhc3MgZmFjdG9yeSBtZXRob2RdKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9yZWZlcmVuY2UuaHRtbCNjbGFzcy1jbGFzcy1mYWN0b3JpZXMpIGZvciB7QGxpbmsgTGF0TG5nfVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gbGF0TG5nKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IExhdExuZyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxyXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBbTWFwYm94IEdlb2NvZGluZ10oaHR0cHM6Ly93d3cubWFwYm94LmNvbS9hcGktZG9jdW1lbnRhdGlvbi8jZ2VvY29kaW5nKVxyXG4gICAqL1xuXG4gIHZhciBNYXBib3ggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcGJveChvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgIHNlcnZpY2VVcmw6ICdodHRwczovL2FwaS5tYXBib3guY29tL2dlb2NvZGluZy92NS9tYXBib3gucGxhY2VzLydcbiAgICAgIH07XG4gICAgICBMX19uYW1lc3BhY2UuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBNYXBib3gucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLl9nZXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gX2dldFByb3BlcnRpZXMobG9jKSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHtcbiAgICAgICAgdGV4dDogbG9jLnRleHQsXG4gICAgICAgIGFkZHJlc3M6IGxvYy5hZGRyZXNzXG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IChsb2MuY29udGV4dCB8fCBbXSkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGlkID0gbG9jLmNvbnRleHRbal0uaWQuc3BsaXQoJy4nKVswXTtcbiAgICAgICAgcHJvcGVydGllc1tpZF0gPSBsb2MuY29udGV4dFtqXS50ZXh0OyAvLyBHZXQgY291bnRyeSBjb2RlIHdoZW4gYXZhaWxhYmxlXG5cbiAgICAgICAgaWYgKGxvYy5jb250ZXh0W2pdLnNob3J0X2NvZGUpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzWydjb3VudHJ5U2hvcnRDb2RlJ10gPSBsb2MuY29udGV4dFtqXS5zaG9ydF9jb2RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH07XG5cbiAgICBfcHJvdG8uZ2VvY29kZSA9IGZ1bmN0aW9uIGdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgcGFyYW1zID0gZ2VvY29kaW5nUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgICBhY2Nlc3NfdG9rZW46IHRoaXMub3B0aW9ucy5hcGlLZXlcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocGFyYW1zLnByb3hpbWl0eSAhPT0gdW5kZWZpbmVkICYmIHBhcmFtcy5wcm94aW1pdHkubGF0ICE9PSB1bmRlZmluZWQgJiYgcGFyYW1zLnByb3hpbWl0eS5sbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJhbXMucHJveGltaXR5ID0gcGFyYW1zLnByb3hpbWl0eS5sbmcgKyAnLCcgKyBwYXJhbXMucHJveGltaXR5LmxhdDtcbiAgICAgIH1cblxuICAgICAgZ2V0SlNPTih0aGlzLm9wdGlvbnMuc2VydmljZVVybCArIGVuY29kZVVSSUNvbXBvbmVudChxdWVyeSkgKyAnLmpzb24nLCBwYXJhbXMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICAgICAgaWYgKGRhdGEuZmVhdHVyZXMgJiYgZGF0YS5mZWF0dXJlcy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBkYXRhLmZlYXR1cmVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxvYyA9IGRhdGEuZmVhdHVyZXNbaV07XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gTF9fbmFtZXNwYWNlLmxhdExuZyhsb2MuY2VudGVyLnJldmVyc2UoKSk7XG4gICAgICAgICAgICB2YXIgYmJveCA9IHZvaWQgMDtcblxuICAgICAgICAgICAgaWYgKGxvYy5iYm94KSB7XG4gICAgICAgICAgICAgIGJib3ggPSBMX19uYW1lc3BhY2UubGF0TG5nQm91bmRzKExfX25hbWVzcGFjZS5sYXRMbmcobG9jLmJib3guc2xpY2UoMCwgMikucmV2ZXJzZSgpKSwgTF9fbmFtZXNwYWNlLmxhdExuZyhsb2MuYmJveC5zbGljZSgyLCA0KS5yZXZlcnNlKCkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJib3ggPSBMX19uYW1lc3BhY2UubGF0TG5nQm91bmRzKGNlbnRlciwgY2VudGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHtcbiAgICAgICAgICAgICAgbmFtZTogbG9jLnBsYWNlX25hbWUsXG4gICAgICAgICAgICAgIGJib3g6IGJib3gsXG4gICAgICAgICAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBfdGhpcy5fZ2V0UHJvcGVydGllcyhsb2MpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0cyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnN1Z2dlc3QgPSBmdW5jdGlvbiBzdWdnZXN0KHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VvY29kZShxdWVyeSwgY2IsIGNvbnRleHQpO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UobG9jYXRpb24sIHNjYWxlLCBjYiwgY29udGV4dCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciB1cmwgPSB0aGlzLm9wdGlvbnMuc2VydmljZVVybCArIGxvY2F0aW9uLmxuZyArICcsJyArIGxvY2F0aW9uLmxhdCArICcuanNvbic7XG4gICAgICB2YXIgcGFyYW0gPSByZXZlcnNlUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgICBhY2Nlc3NfdG9rZW46IHRoaXMub3B0aW9ucy5hcGlLZXlcbiAgICAgIH0pO1xuICAgICAgZ2V0SlNPTih1cmwsIHBhcmFtLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGlmIChkYXRhLmZlYXR1cmVzICYmIGRhdGEuZmVhdHVyZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gZGF0YS5mZWF0dXJlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsb2MgPSBkYXRhLmZlYXR1cmVzW2ldO1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IExfX25hbWVzcGFjZS5sYXRMbmcobG9jLmNlbnRlci5yZXZlcnNlKCkpO1xuICAgICAgICAgICAgdmFyIGJib3ggPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmIChsb2MuYmJveCkge1xuICAgICAgICAgICAgICBiYm94ID0gTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhMX19uYW1lc3BhY2UubGF0TG5nKGxvYy5iYm94LnNsaWNlKDAsIDIpLnJldmVyc2UoKSksIExfX25hbWVzcGFjZS5sYXRMbmcobG9jLmJib3guc2xpY2UoMiwgNCkucmV2ZXJzZSgpKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBiYm94ID0gTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhjZW50ZXIsIGNlbnRlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdHNbaV0gPSB7XG4gICAgICAgICAgICAgIG5hbWU6IGxvYy5wbGFjZV9uYW1lLFxuICAgICAgICAgICAgICBiYm94OiBiYm94LFxuICAgICAgICAgICAgICBjZW50ZXI6IGNlbnRlcixcbiAgICAgICAgICAgICAgcHJvcGVydGllczogX3RoaXMyLl9nZXRQcm9wZXJ0aWVzKGxvYylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCByZXN1bHRzKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWFwYm94O1xuICB9KCk7XG4gIC8qKlxyXG4gICAqIFtDbGFzcyBmYWN0b3J5IG1ldGhvZF0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2NsYXNzLWNsYXNzLWZhY3RvcmllcykgZm9yIHtAbGluayBNYXBib3h9XHJcbiAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnNcclxuICAgKi9cblxuICBmdW5jdGlvbiBtYXBib3gob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgTWFwYm94KG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXHJcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFtNYXBRdWVzdCBHZW9jb2RpbmcgQVBJXShodHRwOi8vZGV2ZWxvcGVyLm1hcHF1ZXN0LmNvbS93ZWIvcHJvZHVjdHMvZGV2LXNlcnZpY2VzL2dlb2NvZGluZy13cylcclxuICAgKi9cblxuICB2YXIgTWFwUXVlc3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcFF1ZXN0KG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgc2VydmljZVVybDogJ2h0dHBzOi8vd3d3Lm1hcHF1ZXN0YXBpLmNvbS9nZW9jb2RpbmcvdjEnXG4gICAgICB9O1xuICAgICAgTF9fbmFtZXNwYWNlLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTsgLy8gTWFwUXVlc3Qgc2VlbXMgdG8gcHJvdmlkZSBVUkkgZW5jb2RlZCBBUEkga2V5cyxcbiAgICAgIC8vIHNvIHRvIGF2b2lkIGVuY29kaW5nIHRoZW0gdHdpY2UsIHdlIGRlY29kZSB0aGVtIGhlcmVcblxuICAgICAgdGhpcy5vcHRpb25zLmFwaUtleSA9IGRlY29kZVVSSUNvbXBvbmVudCh0aGlzLm9wdGlvbnMuYXBpS2V5KTtcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gTWFwUXVlc3QucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLl9mb3JtYXROYW1lID0gZnVuY3Rpb24gX2Zvcm1hdE5hbWUoKSB7XG4gICAgICByZXR1cm4gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gISFzO1xuICAgICAgfSkuam9pbignLCAnKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmdlb2NvZGUgPSBmdW5jdGlvbiBnZW9jb2RlKHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgICAgdmFyIHBhcmFtcyA9IGdlb2NvZGluZ1BhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAga2V5OiB0aGlzLm9wdGlvbnMuYXBpS2V5LFxuICAgICAgICBsb2NhdGlvbjogcXVlcnksXG4gICAgICAgIGxpbWl0OiA1LFxuICAgICAgICBvdXRGb3JtYXQ6ICdqc29uJ1xuICAgICAgfSk7XG4gICAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgJy9hZGRyZXNzJywgcGFyYW1zLCBMX19uYW1lc3BhY2UuVXRpbC5iaW5kKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICAgICAgaWYgKGRhdGEucmVzdWx0cyAmJiBkYXRhLnJlc3VsdHNbMF0ubG9jYXRpb25zKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IGRhdGEucmVzdWx0c1swXS5sb2NhdGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBsb2MgPSBkYXRhLnJlc3VsdHNbMF0ubG9jYXRpb25zW2ldO1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IExfX25hbWVzcGFjZS5sYXRMbmcobG9jLmxhdExuZyk7XG4gICAgICAgICAgICByZXN1bHRzW2ldID0ge1xuICAgICAgICAgICAgICBuYW1lOiB0aGlzLl9mb3JtYXROYW1lKGxvYy5zdHJlZXQsIGxvYy5hZG1pbkFyZWE0LCBsb2MuYWRtaW5BcmVhMywgbG9jLmFkbWluQXJlYTEpLFxuICAgICAgICAgICAgICBiYm94OiBMX19uYW1lc3BhY2UubGF0TG5nQm91bmRzKGNlbnRlciwgY2VudGVyKSxcbiAgICAgICAgICAgICAgY2VudGVyOiBjZW50ZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCByZXN1bHRzKTtcbiAgICAgIH0sIHRoaXMpKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKGxvY2F0aW9uLCBzY2FsZSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBwYXJhbXMgPSByZXZlcnNlUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgICBrZXk6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbi5sYXQgKyAnLCcgKyBsb2NhdGlvbi5sbmcsXG4gICAgICAgIG91dHB1dEZvcm1hdDogJ2pzb24nXG4gICAgICB9KTtcbiAgICAgIGdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwgKyAnL3JldmVyc2UnLCBwYXJhbXMsIExfX25hbWVzcGFjZS5VdGlsLmJpbmQoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBpZiAoZGF0YS5yZXN1bHRzICYmIGRhdGEucmVzdWx0c1swXS5sb2NhdGlvbnMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gZGF0YS5yZXN1bHRzWzBdLmxvY2F0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIGxvYyA9IGRhdGEucmVzdWx0c1swXS5sb2NhdGlvbnNbaV07XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gTF9fbmFtZXNwYWNlLmxhdExuZyhsb2MubGF0TG5nKTtcbiAgICAgICAgICAgIHJlc3VsdHNbaV0gPSB7XG4gICAgICAgICAgICAgIG5hbWU6IHRoaXMuX2Zvcm1hdE5hbWUobG9jLnN0cmVldCwgbG9jLmFkbWluQXJlYTQsIGxvYy5hZG1pbkFyZWEzLCBsb2MuYWRtaW5BcmVhMSksXG4gICAgICAgICAgICAgIGJib3g6IExfX25hbWVzcGFjZS5sYXRMbmdCb3VuZHMoY2VudGVyLCBjZW50ZXIpLFxuICAgICAgICAgICAgICBjZW50ZXI6IGNlbnRlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdHMpO1xuICAgICAgfSwgdGhpcykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWFwUXVlc3Q7XG4gIH0oKTtcbiAgLyoqXHJcbiAgICogW0NsYXNzIGZhY3RvcnkgbWV0aG9kXShodHRwczovL2xlYWZsZXRqcy5jb20vcmVmZXJlbmNlLmh0bWwjY2xhc3MtY2xhc3MtZmFjdG9yaWVzKSBmb3Ige0BsaW5rIE1hcFF1ZXN0fVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gbWFwUXVlc3Qob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgTWFwUXVlc3Qob3B0aW9ucyk7XG4gIH1cblxuICAvKipcclxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgW05ldXRyaW5vIEFQSV0oaHR0cHM6Ly93d3cubmV1dHJpbm9hcGkuY29tL2FwaS9nZW9jb2RlLWFkZHJlc3MvKVxyXG4gICAqL1xuXG4gIHZhciBOZXV0cmlubyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmV1dHJpbm8ob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICB1c2VySWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgYXBpS2V5OiB1bmRlZmluZWQsXG4gICAgICAgIHNlcnZpY2VVcmw6ICdodHRwczovL25ldXRyaW5vYXBpLmNvbS8nXG4gICAgICB9O1xuICAgICAgTF9fbmFtZXNwYWNlLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICB9IC8vIGh0dHBzOi8vd3d3Lm5ldXRyaW5vYXBpLmNvbS9hcGkvZ2VvY29kZS1hZGRyZXNzL1xuXG5cbiAgICB2YXIgX3Byb3RvID0gTmV1dHJpbm8ucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmdlb2NvZGUgPSBmdW5jdGlvbiBnZW9jb2RlKHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgICAgdmFyIHBhcmFtcyA9IGdlb2NvZGluZ1BhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgYXBpS2V5OiB0aGlzLm9wdGlvbnMuYXBpS2V5LFxuICAgICAgICB1c2VySWQ6IHRoaXMub3B0aW9ucy51c2VySWQsXG4gICAgICAgIC8vZ2V0IHRocmVlIHdvcmRzIGFuZCBtYWtlIGEgZG90IGJhc2VkIHN0cmluZ1xuICAgICAgICBhZGRyZXNzOiBxdWVyeS5zcGxpdCgvXFxzKy8pLmpvaW4oJy4nKVxuICAgICAgfSk7XG4gICAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgJ2dlb2NvZGUtYWRkcmVzcycsIHBhcmFtcywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBpZiAoZGF0YS5sb2NhdGlvbnMpIHtcbiAgICAgICAgICBkYXRhLmdlb21ldHJ5ID0gZGF0YS5sb2NhdGlvbnNbMF07XG4gICAgICAgICAgdmFyIGNlbnRlciA9IExfX25hbWVzcGFjZS5sYXRMbmcoZGF0YS5nZW9tZXRyeVsnbGF0aXR1ZGUnXSwgZGF0YS5nZW9tZXRyeVsnbG9uZ2l0dWRlJ10pO1xuICAgICAgICAgIHZhciBiYm94ID0gTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhjZW50ZXIsIGNlbnRlcik7XG4gICAgICAgICAgcmVzdWx0c1swXSA9IHtcbiAgICAgICAgICAgIG5hbWU6IGRhdGEuZ2VvbWV0cnkuYWRkcmVzcyxcbiAgICAgICAgICAgIGJib3g6IGJib3gsXG4gICAgICAgICAgICBjZW50ZXI6IGNlbnRlclxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdHMpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9wcm90by5zdWdnZXN0ID0gZnVuY3Rpb24gc3VnZ2VzdChxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KTtcbiAgICB9IC8vIGh0dHBzOi8vd3d3Lm5ldXRyaW5vYXBpLmNvbS9hcGkvZ2VvY29kZS1yZXZlcnNlL1xuICAgIDtcblxuICAgIF9wcm90by5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZShsb2NhdGlvbiwgc2NhbGUsIGNiLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcGFyYW1zID0gcmV2ZXJzZVBhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgYXBpS2V5OiB0aGlzLm9wdGlvbnMuYXBpS2V5LFxuICAgICAgICB1c2VySWQ6IHRoaXMub3B0aW9ucy51c2VySWQsXG4gICAgICAgIGxhdGl0dWRlOiBsb2NhdGlvbi5sYXQsXG4gICAgICAgIGxvbmdpdHVkZTogbG9jYXRpb24ubG5nXG4gICAgICB9KTtcbiAgICAgIGdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwgKyAnZ2VvY29kZS1yZXZlcnNlJywgcGFyYW1zLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGlmIChkYXRhLnN0YXR1cy5zdGF0dXMgPT0gMjAwICYmIGRhdGEuZm91bmQpIHtcbiAgICAgICAgICB2YXIgY2VudGVyID0gTF9fbmFtZXNwYWNlLmxhdExuZyhsb2NhdGlvbi5sYXQsIGxvY2F0aW9uLmxuZyk7XG4gICAgICAgICAgdmFyIGJib3ggPSBMX19uYW1lc3BhY2UubGF0TG5nQm91bmRzKGNlbnRlciwgY2VudGVyKTtcbiAgICAgICAgICByZXN1bHRzWzBdID0ge1xuICAgICAgICAgICAgbmFtZTogZGF0YS5hZGRyZXNzLFxuICAgICAgICAgICAgYmJveDogYmJveCxcbiAgICAgICAgICAgIGNlbnRlcjogY2VudGVyXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0cyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE5ldXRyaW5vO1xuICB9KCk7XG4gIC8qKlxyXG4gICAqIFtDbGFzcyBmYWN0b3J5IG1ldGhvZF0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2NsYXNzLWNsYXNzLWZhY3RvcmllcykgZm9yIHtAbGluayBOZXV0cmlub31cclxuICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9uc1xyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG5ldXRyaW5vKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IE5ldXRyaW5vKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXHJcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFtOb21pbmF0aW1dKGh0dHBzOi8vd2lraS5vcGVuc3RyZWV0bWFwLm9yZy93aWtpL05vbWluYXRpbSkgZ2VvY29kZXIuXHJcbiAgICpcclxuICAgKiBUaGlzIGlzIHRoZSBkZWZhdWx0IGdlb2NvZGluZyBzZXJ2aWNlIHVzZWQgYnkgdGhlIGNvbnRyb2wsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkIGluIHRoZSBvcHRpb25zLlxyXG4gICAqXHJcbiAgICogVW5sZXNzIHVzaW5nIHlvdXIgb3duIE5vbWluYXRpbSBpbnN0YWxsYXRpb24sIHBsZWFzZSByZWZlciB0byB0aGUgW05vbWluYXRpbSB1c2FnZSBwb2xpY3ldKGh0dHBzOi8vb3BlcmF0aW9ucy5vc21mb3VuZGF0aW9uLm9yZy9wb2xpY2llcy9ub21pbmF0aW0vKS5cclxuICAgKi9cblxuICB2YXIgTm9taW5hdGltID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb21pbmF0aW0ob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBzZXJ2aWNlVXJsOiAnaHR0cHM6Ly9ub21pbmF0aW0ub3BlbnN0cmVldG1hcC5vcmcvJyxcbiAgICAgICAgaHRtbFRlbXBsYXRlOiBmdW5jdGlvbiBodG1sVGVtcGxhdGUocikge1xuICAgICAgICAgIHZhciBhZGRyZXNzID0gci5hZGRyZXNzO1xuICAgICAgICAgIHZhciBjbGFzc05hbWU7XG4gICAgICAgICAgdmFyIHBhcnRzID0gW107XG5cbiAgICAgICAgICBpZiAoYWRkcmVzcy5yb2FkIHx8IGFkZHJlc3MuYnVpbGRpbmcpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goJ3tidWlsZGluZ30ge3JvYWR9IHtob3VzZV9udW1iZXJ9Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFkZHJlc3MuY2l0eSB8fCBhZGRyZXNzLnRvd24gfHwgYWRkcmVzcy52aWxsYWdlIHx8IGFkZHJlc3MuaGFtbGV0KSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBwYXJ0cy5sZW5ndGggPiAwID8gJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1hZGRyZXNzLWRldGFpbCcgOiAnJztcbiAgICAgICAgICAgIHBhcnRzLnB1c2goJzxzcGFuIGNsYXNzPVwiJyArIGNsYXNzTmFtZSArICdcIj57cG9zdGNvZGV9IHtjaXR5fSB7dG93bn0ge3ZpbGxhZ2V9IHtoYW1sZXR9PC9zcGFuPicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhZGRyZXNzLnN0YXRlIHx8IGFkZHJlc3MuY291bnRyeSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gcGFydHMubGVuZ3RoID4gMCA/ICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItYWRkcmVzcy1jb250ZXh0JyA6ICcnO1xuICAgICAgICAgICAgcGFydHMucHVzaCgnPHNwYW4gY2xhc3M9XCInICsgY2xhc3NOYW1lICsgJ1wiPntzdGF0ZX0ge2NvdW50cnl9PC9zcGFuPicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZShwYXJ0cy5qb2luKCc8YnIvPicpLCBhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIExfX25hbWVzcGFjZS5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyB8fCB7fSk7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IE5vbWluYXRpbS5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZ2VvY29kZSA9IGZ1bmN0aW9uIGdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgcGFyYW1zID0gZ2VvY29kaW5nUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgICBxOiBxdWVyeSxcbiAgICAgICAgbGltaXQ6IDUsXG4gICAgICAgIGZvcm1hdDogJ2pzb24nLFxuICAgICAgICBhZGRyZXNzZGV0YWlsczogMVxuICAgICAgfSk7XG4gICAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgJ3NlYXJjaCcsIHBhcmFtcywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBiYm94ID0gZGF0YVtpXS5ib3VuZGluZ2JveDtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICBiYm94W2pdID0gK2Jib3hbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0c1tpXSA9IHtcbiAgICAgICAgICAgIGljb246IGRhdGFbaV0uaWNvbixcbiAgICAgICAgICAgIG5hbWU6IGRhdGFbaV0uZGlzcGxheV9uYW1lLFxuICAgICAgICAgICAgaHRtbDogX3RoaXMub3B0aW9ucy5odG1sVGVtcGxhdGUgPyBfdGhpcy5vcHRpb25zLmh0bWxUZW1wbGF0ZShkYXRhW2ldKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGJib3g6IExfX25hbWVzcGFjZS5sYXRMbmdCb3VuZHMoW2Jib3hbMF0sIGJib3hbMl1dLCBbYmJveFsxXSwgYmJveFszXV0pLFxuICAgICAgICAgICAgY2VudGVyOiBMX19uYW1lc3BhY2UubGF0TG5nKGRhdGFbaV0ubGF0LCBkYXRhW2ldLmxvbiksXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBkYXRhW2ldXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0cyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKGxvY2F0aW9uLCBzY2FsZSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgcGFyYW1zID0gcmV2ZXJzZVBhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgbGF0OiBsb2NhdGlvbi5sYXQsXG4gICAgICAgIGxvbjogbG9jYXRpb24ubG5nLFxuICAgICAgICB6b29tOiBNYXRoLnJvdW5kKE1hdGgubG9nKHNjYWxlIC8gMjU2KSAvIE1hdGgubG9nKDIpKSxcbiAgICAgICAgYWRkcmVzc2RldGFpbHM6IDEsXG4gICAgICAgIGZvcm1hdDogJ2pzb24nXG4gICAgICB9KTtcbiAgICAgIGdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwgKyAncmV2ZXJzZScsIHBhcmFtcywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEubGF0ICYmIGRhdGEubG9uKSB7XG4gICAgICAgICAgdmFyIGNlbnRlciA9IExfX25hbWVzcGFjZS5sYXRMbmcoZGF0YS5sYXQsIGRhdGEubG9uKTtcbiAgICAgICAgICB2YXIgYmJveCA9IExfX25hbWVzcGFjZS5sYXRMbmdCb3VuZHMoY2VudGVyLCBjZW50ZXIpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IGRhdGEuZGlzcGxheV9uYW1lLFxuICAgICAgICAgICAgaHRtbDogX3RoaXMyLm9wdGlvbnMuaHRtbFRlbXBsYXRlID8gX3RoaXMyLm9wdGlvbnMuaHRtbFRlbXBsYXRlKGRhdGEpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICAgICAgICBiYm94OiBiYm94LFxuICAgICAgICAgICAgcHJvcGVydGllczogZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBOb21pbmF0aW07XG4gIH0oKTtcbiAgLyoqXHJcbiAgICogW0NsYXNzIGZhY3RvcnkgbWV0aG9kXShodHRwczovL2xlYWZsZXRqcy5jb20vcmVmZXJlbmNlLmh0bWwjY2xhc3MtY2xhc3MtZmFjdG9yaWVzKSBmb3Ige0BsaW5rIE5vbWluYXRpbX1cclxuICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9uc1xyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG5vbWluYXRpbShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBOb21pbmF0aW0ob3B0aW9ucyk7XG4gIH1cblxuICAvKipcclxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgW1BsdXMgY29kZXNdKGh0dHBzOi8vcGx1cy5jb2Rlcy8pIChmb3JtZXJseSBPcGVuTG9jYXRpb25Db2RlKSAocmVxdWlyZXMgW29wZW4tbG9jYXRpb24tY29kZV0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb3Blbi1sb2NhdGlvbi1jb2RlKSlcclxuICAgKi9cblxuICB2YXIgT3BlbkxvY2F0aW9uQ29kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3BlbkxvY2F0aW9uQ29kZShvcHRpb25zKSB7XG4gICAgICBMX19uYW1lc3BhY2UuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBPcGVuTG9jYXRpb25Db2RlLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5nZW9jb2RlID0gZnVuY3Rpb24gZ2VvY29kZShxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBkZWNvZGVkID0gdGhpcy5vcHRpb25zLk9wZW5Mb2NhdGlvbkNvZGUuZGVjb2RlKHF1ZXJ5KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICBuYW1lOiBxdWVyeSxcbiAgICAgICAgICBjZW50ZXI6IExfX25hbWVzcGFjZS5sYXRMbmcoZGVjb2RlZC5sYXRpdHVkZUNlbnRlciwgZGVjb2RlZC5sb25naXR1ZGVDZW50ZXIpLFxuICAgICAgICAgIGJib3g6IExfX25hbWVzcGFjZS5sYXRMbmdCb3VuZHMoTF9fbmFtZXNwYWNlLmxhdExuZyhkZWNvZGVkLmxhdGl0dWRlTG8sIGRlY29kZWQubG9uZ2l0dWRlTG8pLCBMX19uYW1lc3BhY2UubGF0TG5nKGRlY29kZWQubGF0aXR1ZGVIaSwgZGVjb2RlZC5sb25naXR1ZGVIaSkpXG4gICAgICAgIH07XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgW3Jlc3VsdF0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuXG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgW10pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8ucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UobG9jYXRpb24sIHNjYWxlLCBjYiwgY29udGV4dCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGNvZGUgPSB0aGlzLm9wdGlvbnMuT3BlbkxvY2F0aW9uQ29kZS5lbmNvZGUobG9jYXRpb24ubGF0LCBsb2NhdGlvbi5sbmcsIHRoaXMub3B0aW9ucy5jb2RlTGVuZ3RoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICBuYW1lOiBjb2RlLFxuICAgICAgICAgIGNlbnRlcjogTF9fbmFtZXNwYWNlLmxhdExuZyhsb2NhdGlvbi5sYXQsIGxvY2F0aW9uLmxuZyksXG4gICAgICAgICAgYmJveDogTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhMX19uYW1lc3BhY2UubGF0TG5nKGxvY2F0aW9uLmxhdCwgbG9jYXRpb24ubG5nKSwgTF9fbmFtZXNwYWNlLmxhdExuZyhsb2NhdGlvbi5sYXQsIGxvY2F0aW9uLmxuZykpXG4gICAgICAgIH07XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgW3Jlc3VsdF0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuXG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgW10pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gT3BlbkxvY2F0aW9uQ29kZTtcbiAgfSgpO1xuICAvKipcclxuICAgKiBbQ2xhc3MgZmFjdG9yeSBtZXRob2RdKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9yZWZlcmVuY2UuaHRtbCNjbGFzcy1jbGFzcy1mYWN0b3JpZXMpIGZvciB7QGxpbmsgT3BlbkxvY2F0aW9uQ29kZX1cclxuICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9uc1xyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9wZW5Mb2NhdGlvbkNvZGUob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgT3BlbkxvY2F0aW9uQ29kZShvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxyXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBbT3BlbkNhZ2UgRGF0YSBBUEldKGh0dHBzOi8vb3BlbmNhZ2VkYXRhLmNvbS8pXHJcbiAgICovXG5cbiAgdmFyIE9wZW5DYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcGVuQ2FnZShvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgIHNlcnZpY2VVcmw6ICdodHRwczovL2FwaS5vcGVuY2FnZWRhdGEuY29tL2dlb2NvZGUvdjEvanNvbidcbiAgICAgIH07XG4gICAgICBMX19uYW1lc3BhY2UuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBPcGVuQ2FnZS5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZ2VvY29kZSA9IGZ1bmN0aW9uIGdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcGFyYW1zID0gZ2VvY29kaW5nUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgICBrZXk6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICAgIHE6IHF1ZXJ5XG4gICAgICB9KTtcbiAgICAgIGdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwsIHBhcmFtcywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBpZiAoZGF0YS5yZXN1bHRzICYmIGRhdGEucmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEucmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxvYyA9IGRhdGEucmVzdWx0c1tpXTtcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSBMX19uYW1lc3BhY2UubGF0TG5nKGxvYy5nZW9tZXRyeSk7XG4gICAgICAgICAgICB2YXIgYmJveCA9IHZvaWQgMDtcblxuICAgICAgICAgICAgaWYgKGxvYy5hbm5vdGF0aW9ucyAmJiBsb2MuYW5ub3RhdGlvbnMuYm91bmRzKSB7XG4gICAgICAgICAgICAgIGJib3ggPSBMX19uYW1lc3BhY2UubGF0TG5nQm91bmRzKExfX25hbWVzcGFjZS5sYXRMbmcobG9jLmFubm90YXRpb25zLmJvdW5kcy5ub3J0aGVhc3QpLCBMX19uYW1lc3BhY2UubGF0TG5nKGxvYy5hbm5vdGF0aW9ucy5ib3VuZHMuc291dGh3ZXN0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBiYm94ID0gTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhjZW50ZXIsIGNlbnRlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgIG5hbWU6IGxvYy5mb3JtYXR0ZWQsXG4gICAgICAgICAgICAgIGJib3g6IGJib3gsXG4gICAgICAgICAgICAgIGNlbnRlcjogY2VudGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdHMpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9wcm90by5zdWdnZXN0ID0gZnVuY3Rpb24gc3VnZ2VzdChxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKGxvY2F0aW9uLCBzY2FsZSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBwYXJhbXMgPSByZXZlcnNlUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgICBrZXk6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICAgIHE6IFtsb2NhdGlvbi5sYXQsIGxvY2F0aW9uLmxuZ10uam9pbignLCcpXG4gICAgICB9KTtcbiAgICAgIGdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwsIHBhcmFtcywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBpZiAoZGF0YS5yZXN1bHRzICYmIGRhdGEucmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEucmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxvYyA9IGRhdGEucmVzdWx0c1tpXTtcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSBMX19uYW1lc3BhY2UubGF0TG5nKGxvYy5nZW9tZXRyeSk7XG4gICAgICAgICAgICB2YXIgYmJveCA9IHZvaWQgMDtcblxuICAgICAgICAgICAgaWYgKGxvYy5hbm5vdGF0aW9ucyAmJiBsb2MuYW5ub3RhdGlvbnMuYm91bmRzKSB7XG4gICAgICAgICAgICAgIGJib3ggPSBMX19uYW1lc3BhY2UubGF0TG5nQm91bmRzKExfX25hbWVzcGFjZS5sYXRMbmcobG9jLmFubm90YXRpb25zLmJvdW5kcy5ub3J0aGVhc3QpLCBMX19uYW1lc3BhY2UubGF0TG5nKGxvYy5hbm5vdGF0aW9ucy5ib3VuZHMuc291dGh3ZXN0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBiYm94ID0gTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhjZW50ZXIsIGNlbnRlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgIG5hbWU6IGxvYy5mb3JtYXR0ZWQsXG4gICAgICAgICAgICAgIGJib3g6IGJib3gsXG4gICAgICAgICAgICAgIGNlbnRlcjogY2VudGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdHMpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBPcGVuQ2FnZTtcbiAgfSgpO1xuICBmdW5jdGlvbiBvcGVuY2FnZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBPcGVuQ2FnZShvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxyXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBbUGVsaWFzXShodHRwczovL3BlbGlhcy5pby8pLCBbZ2VvY29kZS5lYXJ0aF0oaHR0cHM6Ly9nZW9jb2RlLmVhcnRoLykgZ2VvY29kZXIgKGZvcm1lcmx5IE1hcHplbiBTZWFyY2gpXHJcbiAgICovXG5cbiAgdmFyIFBlbGlhcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGVsaWFzKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgc2VydmljZVVybDogJ2h0dHBzOi8vYXBpLmdlb2NvZGUuZWFydGgvdjEnXG4gICAgICB9O1xuICAgICAgdGhpcy5fbGFzdFN1Z2dlc3QgPSAwO1xuICAgICAgTF9fbmFtZXNwYWNlLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gUGVsaWFzLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5nZW9jb2RlID0gZnVuY3Rpb24gZ2VvY29kZShxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBwYXJhbXMgPSBnZW9jb2RpbmdQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICAgIGFwaV9rZXk6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICAgIHRleHQ6IHF1ZXJ5XG4gICAgICB9KTtcbiAgICAgIGdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwgKyAnL3NlYXJjaCcsIHBhcmFtcywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCBfdGhpcy5fcGFyc2VSZXN1bHRzKGRhdGEsICdiYm94JykpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9wcm90by5zdWdnZXN0ID0gZnVuY3Rpb24gc3VnZ2VzdChxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgcGFyYW1zID0gZ2VvY29kaW5nUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgICBhcGlfa2V5OiB0aGlzLm9wdGlvbnMuYXBpS2V5LFxuICAgICAgICB0ZXh0OiBxdWVyeVxuICAgICAgfSk7XG4gICAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgJy9hdXRvY29tcGxldGUnLCBwYXJhbXMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmdlb2NvZGluZy50aW1lc3RhbXAgPiBfdGhpczIuX2xhc3RTdWdnZXN0KSB7XG4gICAgICAgICAgX3RoaXMyLl9sYXN0U3VnZ2VzdCA9IGRhdGEuZ2VvY29kaW5nLnRpbWVzdGFtcDtcbiAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIF90aGlzMi5fcGFyc2VSZXN1bHRzKGRhdGEsICdiYm94JykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKGxvY2F0aW9uLCBzY2FsZSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgcGFyYW1zID0gcmV2ZXJzZVBhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgYXBpX2tleTogdGhpcy5vcHRpb25zLmFwaUtleSxcbiAgICAgICAgJ3BvaW50LmxhdCc6IGxvY2F0aW9uLmxhdCxcbiAgICAgICAgJ3BvaW50Lmxvbic6IGxvY2F0aW9uLmxuZ1xuICAgICAgfSk7XG4gICAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgJy9yZXZlcnNlJywgcGFyYW1zLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIF90aGlzMy5fcGFyc2VSZXN1bHRzKGRhdGEsICdib3VuZHMnKSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9wYXJzZVJlc3VsdHMgPSBmdW5jdGlvbiBfcGFyc2VSZXN1bHRzKGRhdGEsIGJib3huYW1lKSB7XG4gICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgTF9fbmFtZXNwYWNlLmdlb0pTT04oZGF0YSwge1xuICAgICAgICBwb2ludFRvTGF5ZXI6IGZ1bmN0aW9uIHBvaW50VG9MYXllcihmZWF0dXJlLCBsYXRsbmcpIHtcbiAgICAgICAgICByZXR1cm4gTF9fbmFtZXNwYWNlLmNpcmNsZU1hcmtlcihsYXRsbmcpO1xuICAgICAgICB9LFxuICAgICAgICBvbkVhY2hGZWF0dXJlOiBmdW5jdGlvbiBvbkVhY2hGZWF0dXJlKGZlYXR1cmUsIGxheWVyKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgIHZhciBiYm94O1xuICAgICAgICAgIHZhciBjZW50ZXI7XG5cbiAgICAgICAgICBpZiAobGF5ZXIuZ2V0Qm91bmRzKSB7XG4gICAgICAgICAgICBiYm94ID0gbGF5ZXIuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICBjZW50ZXIgPSBiYm94LmdldENlbnRlcigpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGF5ZXIuZmVhdHVyZS5iYm94KSB7XG4gICAgICAgICAgICBjZW50ZXIgPSBsYXllci5nZXRMYXRMbmcoKTtcbiAgICAgICAgICAgIGJib3ggPSBMX19uYW1lc3BhY2UubGF0TG5nQm91bmRzKExfX25hbWVzcGFjZS5HZW9KU09OLmNvb3Jkc1RvTGF0TG5nKGxheWVyLmZlYXR1cmUuYmJveC5zbGljZSgwLCAyKSksIExfX25hbWVzcGFjZS5HZW9KU09OLmNvb3Jkc1RvTGF0TG5nKGxheWVyLmZlYXR1cmUuYmJveC5zbGljZSgyLCA0KSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjZW50ZXIgPSBsYXllci5nZXRMYXRMbmcoKTtcbiAgICAgICAgICAgIGJib3ggPSBMX19uYW1lc3BhY2UubGF0TG5nQm91bmRzKGNlbnRlciwgY2VudGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQubmFtZSA9IGxheWVyLmZlYXR1cmUucHJvcGVydGllcy5sYWJlbDtcbiAgICAgICAgICByZXN1bHQuY2VudGVyID0gY2VudGVyO1xuICAgICAgICAgIHJlc3VsdFtiYm94bmFtZV0gPSBiYm94O1xuICAgICAgICAgIHJlc3VsdC5wcm9wZXJ0aWVzID0gbGF5ZXIuZmVhdHVyZS5wcm9wZXJ0aWVzO1xuICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG5cbiAgICByZXR1cm4gUGVsaWFzO1xuICB9KCk7XG4gIC8qKlxyXG4gICAqIFtDbGFzcyBmYWN0b3J5IG1ldGhvZF0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2NsYXNzLWNsYXNzLWZhY3RvcmllcykgZm9yIHtAbGluayBQZWxpYXN9XHJcbiAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnNcclxuICAgKi9cblxuICBmdW5jdGlvbiBwZWxpYXMob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGVsaWFzKG9wdGlvbnMpO1xuICB9XG4gIHZhciBHZW9jb2RlRWFydGggPSBQZWxpYXM7XG4gIHZhciBnZW9jb2RlRWFydGggPSBwZWxpYXM7XG4gIC8qKlxyXG4gICAqIHIuaS5wLlxyXG4gICAqIEBkZXByZWNhdGVkXHJcbiAgICovXG5cbiAgdmFyIE1hcHplbiA9IFBlbGlhcztcbiAgLyoqXHJcbiAgICogci5pLnAuXHJcbiAgICogQGRlcHJlY2F0ZWRcclxuICAgKi9cblxuICB2YXIgbWFwemVuID0gcGVsaWFzO1xuICAvKipcclxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgW09wZW5yb3V0ZXNlcnZpY2VdKGh0dHBzOi8vb3BlbnJvdXRlc2VydmljZS5vcmcvZGV2LyMvYXBpLWRvY3MvZ2VvY29kZSkgZ2VvY29kZXJcclxuICAgKi9cblxuICB2YXIgT3BlbnJvdXRlc2VydmljZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BlbGlhcykge1xuICAgIF9pbmhlcml0c0xvb3NlKE9wZW5yb3V0ZXNlcnZpY2UsIF9QZWxpYXMpO1xuXG4gICAgZnVuY3Rpb24gT3BlbnJvdXRlc2VydmljZShvcHRpb25zKSB7XG4gICAgICByZXR1cm4gX1BlbGlhcy5jYWxsKHRoaXMsIExfX25hbWVzcGFjZS5VdGlsLmV4dGVuZCh7XG4gICAgICAgIHNlcnZpY2VVcmw6ICdodHRwczovL2FwaS5vcGVucm91dGVzZXJ2aWNlLm9yZy9nZW9jb2RlJ1xuICAgICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9wZW5yb3V0ZXNlcnZpY2U7XG4gIH0oUGVsaWFzKTtcbiAgLyoqXHJcbiAgICogW0NsYXNzIGZhY3RvcnkgbWV0aG9kXShodHRwczovL2xlYWZsZXRqcy5jb20vcmVmZXJlbmNlLmh0bWwjY2xhc3MtY2xhc3MtZmFjdG9yaWVzKSBmb3Ige0BsaW5rIE9wZW5yb3V0ZXNlcnZpY2V9XHJcbiAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnNcclxuICAgKi9cblxuICBmdW5jdGlvbiBvcGVucm91dGVzZXJ2aWNlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IE9wZW5yb3V0ZXNlcnZpY2Uob3B0aW9ucyk7XG4gIH1cblxuICAvKipcclxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgW1Bob3Rvbl0oaHR0cDovL3Bob3Rvbi5rb21vb3QuZGUvKSBnZW9jb2RlclxyXG4gICAqL1xuXG4gIHZhciBQaG90b24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBob3RvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgIHNlcnZpY2VVcmw6ICdodHRwczovL3Bob3Rvbi5rb21vb3QuaW8vYXBpLycsXG4gICAgICAgIHJldmVyc2VVcmw6ICdodHRwczovL3Bob3Rvbi5rb21vb3QuaW8vcmV2ZXJzZS8nLFxuICAgICAgICBuYW1lUHJvcGVydGllczogWyduYW1lJywgJ3N0cmVldCcsICdzdWJ1cmInLCAnaGFtbGV0JywgJ3Rvd24nLCAnY2l0eScsICdzdGF0ZScsICdjb3VudHJ5J11cbiAgICAgIH07XG4gICAgICBMX19uYW1lc3BhY2UuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBQaG90b24ucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmdlb2NvZGUgPSBmdW5jdGlvbiBnZW9jb2RlKHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgICAgdmFyIHBhcmFtcyA9IGdlb2NvZGluZ1BhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgcTogcXVlcnlcbiAgICAgIH0pO1xuICAgICAgZ2V0SlNPTih0aGlzLm9wdGlvbnMuc2VydmljZVVybCwgcGFyYW1zLCBMX19uYW1lc3BhY2UuVXRpbC5iaW5kKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcy5fZGVjb2RlRmVhdHVyZXMoZGF0YSkpO1xuICAgICAgfSwgdGhpcykpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uc3VnZ2VzdCA9IGZ1bmN0aW9uIHN1Z2dlc3QocXVlcnksIGNiLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW9jb2RlKHF1ZXJ5LCBjYiwgY29udGV4dCk7XG4gICAgfTtcblxuICAgIF9wcm90by5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZShsYXRMbmcsIHNjYWxlLCBjYiwgY29udGV4dCkge1xuICAgICAgdmFyIHBhcmFtcyA9IHJldmVyc2VQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICAgIGxhdDogbGF0TG5nLmxhdCxcbiAgICAgICAgbG9uOiBsYXRMbmcubG5nXG4gICAgICB9KTtcbiAgICAgIGdldEpTT04odGhpcy5vcHRpb25zLnJldmVyc2VVcmwsIHBhcmFtcywgTF9fbmFtZXNwYWNlLlV0aWwuYmluZChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMuX2RlY29kZUZlYXR1cmVzKGRhdGEpKTtcbiAgICAgIH0sIHRoaXMpKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9kZWNvZGVGZWF0dXJlcyA9IGZ1bmN0aW9uIF9kZWNvZGVGZWF0dXJlcyhkYXRhKSB7XG4gICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLmZlYXR1cmVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBmID0gZGF0YS5mZWF0dXJlc1tpXTtcbiAgICAgICAgICB2YXIgYyA9IGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgdmFyIGNlbnRlciA9IExfX25hbWVzcGFjZS5sYXRMbmcoY1sxXSwgY1swXSk7XG4gICAgICAgICAgdmFyIGV4dGVudCA9IGYucHJvcGVydGllcy5leHRlbnQ7XG4gICAgICAgICAgdmFyIGJib3ggPSBleHRlbnQgPyBMX19uYW1lc3BhY2UubGF0TG5nQm91bmRzKFtleHRlbnRbMV0sIGV4dGVudFswXV0sIFtleHRlbnRbM10sIGV4dGVudFsyXV0pIDogTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhjZW50ZXIsIGNlbnRlcik7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuX2RlY29kZUZlYXR1cmVOYW1lKGYpLFxuICAgICAgICAgICAgaHRtbDogdGhpcy5vcHRpb25zLmh0bWxUZW1wbGF0ZSA/IHRoaXMub3B0aW9ucy5odG1sVGVtcGxhdGUoZikgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjZW50ZXI6IGNlbnRlcixcbiAgICAgICAgICAgIGJib3g6IGJib3gsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBmLnByb3BlcnRpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9kZWNvZGVGZWF0dXJlTmFtZSA9IGZ1bmN0aW9uIF9kZWNvZGVGZWF0dXJlTmFtZShmKSB7XG4gICAgICByZXR1cm4gKHRoaXMub3B0aW9ucy5uYW1lUHJvcGVydGllcyB8fCBbXSkubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBmLnByb3BlcnRpZXNbcF07XG4gICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuICEhdjtcbiAgICAgIH0pLmpvaW4oJywgJyk7XG4gICAgfTtcblxuICAgIHJldHVybiBQaG90b247XG4gIH0oKTtcbiAgLyoqXHJcbiAgICogW0NsYXNzIGZhY3RvcnkgbWV0aG9kXShodHRwczovL2xlYWZsZXRqcy5jb20vcmVmZXJlbmNlLmh0bWwjY2xhc3MtY2xhc3MtZmFjdG9yaWVzKSBmb3Ige0BsaW5rIFBob3Rvbn1cclxuICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9uc1xyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHBob3RvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQaG90b24ob3B0aW9ucyk7XG4gIH1cblxuICAvKipcclxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgV2hhdDNXb3JkcyBzZXJ2aWNlXHJcbiAgICovXG5cbiAgdmFyIFdoYXQzV29yZHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdoYXQzV29yZHMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBzZXJ2aWNlVXJsOiAnaHR0cHM6Ly9hcGkud2hhdDN3b3Jkcy5jb20vdjIvJ1xuICAgICAgfTtcbiAgICAgIExfX25hbWVzcGFjZS5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IFdoYXQzV29yZHMucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmdlb2NvZGUgPSBmdW5jdGlvbiBnZW9jb2RlKHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgICAgLy9nZXQgdGhyZWUgd29yZHMgYW5kIG1ha2UgYSBkb3QgYmFzZWQgc3RyaW5nXG4gICAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgJ2ZvcndhcmQnLCBnZW9jb2RpbmdQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICAgIGtleTogdGhpcy5vcHRpb25zLmFwaUtleSxcbiAgICAgICAgYWRkcjogcXVlcnkuc3BsaXQoL1xccysvKS5qb2luKCcuJylcbiAgICAgIH0pLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGlmIChkYXRhLmdlb21ldHJ5KSB7XG4gICAgICAgICAgdmFyIGxhdExuZyA9IExfX25hbWVzcGFjZS5sYXRMbmcoZGF0YS5nZW9tZXRyeVsnbGF0J10sIGRhdGEuZ2VvbWV0cnlbJ2xuZyddKTtcbiAgICAgICAgICB2YXIgbGF0TG5nQm91bmRzID0gTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhsYXRMbmcsIGxhdExuZyk7XG4gICAgICAgICAgcmVzdWx0c1swXSA9IHtcbiAgICAgICAgICAgIG5hbWU6IGRhdGEud29yZHMsXG4gICAgICAgICAgICBiYm94OiBsYXRMbmdCb3VuZHMsXG4gICAgICAgICAgICBjZW50ZXI6IGxhdExuZ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdHMpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9wcm90by5zdWdnZXN0ID0gZnVuY3Rpb24gc3VnZ2VzdChxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKGxvY2F0aW9uLCBzY2FsZSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIGdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwgKyAncmV2ZXJzZScsIHJldmVyc2VQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICAgIGtleTogdGhpcy5vcHRpb25zLmFwaUtleSxcbiAgICAgICAgY29vcmRzOiBbbG9jYXRpb24ubGF0LCBsb2NhdGlvbi5sbmddLmpvaW4oJywnKVxuICAgICAgfSksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICAgICAgaWYgKGRhdGEuc3RhdHVzLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgICB2YXIgY2VudGVyID0gTF9fbmFtZXNwYWNlLmxhdExuZyhkYXRhLmdlb21ldHJ5WydsYXQnXSwgZGF0YS5nZW9tZXRyeVsnbG5nJ10pO1xuICAgICAgICAgIHZhciBiYm94ID0gTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhjZW50ZXIsIGNlbnRlcik7XG4gICAgICAgICAgcmVzdWx0c1swXSA9IHtcbiAgICAgICAgICAgIG5hbWU6IGRhdGEud29yZHMsXG4gICAgICAgICAgICBiYm94OiBiYm94LFxuICAgICAgICAgICAgY2VudGVyOiBjZW50ZXJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCByZXN1bHRzKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gV2hhdDNXb3JkcztcbiAgfSgpO1xuICAvKipcclxuICAgKiBbQ2xhc3MgZmFjdG9yeSBtZXRob2RdKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9yZWZlcmVuY2UuaHRtbCNjbGFzcy1jbGFzcy1mYWN0b3JpZXMpIGZvciB7QGxpbmsgV2hhdDNXb3Jkc31cclxuICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9uc1xyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHdoYXQzd29yZHMob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgV2hhdDNXb3JkcyhvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBnZW9jb2RlcnMgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdlb2NvZGluZ1BhcmFtczogZ2VvY29kaW5nUGFyYW1zLFxuICAgIHJldmVyc2VQYXJhbXM6IHJldmVyc2VQYXJhbXMsXG4gICAgQXJjR2lzOiBBcmNHaXMsXG4gICAgYXJjZ2lzOiBhcmNnaXMsXG4gICAgQmluZzogQmluZyxcbiAgICBiaW5nOiBiaW5nLFxuICAgIEdvb2dsZTogR29vZ2xlLFxuICAgIGdvb2dsZTogZ29vZ2xlLFxuICAgIEhFUkU6IEhFUkUsXG4gICAgSEVSRXYyOiBIRVJFdjIsXG4gICAgaGVyZTogaGVyZSxcbiAgICBwYXJzZUxhdExuZzogcGFyc2VMYXRMbmcsXG4gICAgTGF0TG5nOiBMYXRMbmcsXG4gICAgbGF0TG5nOiBsYXRMbmcsXG4gICAgTWFwYm94OiBNYXBib3gsXG4gICAgbWFwYm94OiBtYXBib3gsXG4gICAgTWFwUXVlc3Q6IE1hcFF1ZXN0LFxuICAgIG1hcFF1ZXN0OiBtYXBRdWVzdCxcbiAgICBOZXV0cmlubzogTmV1dHJpbm8sXG4gICAgbmV1dHJpbm86IG5ldXRyaW5vLFxuICAgIE5vbWluYXRpbTogTm9taW5hdGltLFxuICAgIG5vbWluYXRpbTogbm9taW5hdGltLFxuICAgIE9wZW5Mb2NhdGlvbkNvZGU6IE9wZW5Mb2NhdGlvbkNvZGUsXG4gICAgb3BlbkxvY2F0aW9uQ29kZTogb3BlbkxvY2F0aW9uQ29kZSxcbiAgICBPcGVuQ2FnZTogT3BlbkNhZ2UsXG4gICAgb3BlbmNhZ2U6IG9wZW5jYWdlLFxuICAgIFBlbGlhczogUGVsaWFzLFxuICAgIHBlbGlhczogcGVsaWFzLFxuICAgIEdlb2NvZGVFYXJ0aDogR2VvY29kZUVhcnRoLFxuICAgIGdlb2NvZGVFYXJ0aDogZ2VvY29kZUVhcnRoLFxuICAgIE1hcHplbjogTWFwemVuLFxuICAgIG1hcHplbjogbWFwemVuLFxuICAgIE9wZW5yb3V0ZXNlcnZpY2U6IE9wZW5yb3V0ZXNlcnZpY2UsXG4gICAgb3BlbnJvdXRlc2VydmljZTogb3BlbnJvdXRlc2VydmljZSxcbiAgICBQaG90b246IFBob3RvbixcbiAgICBwaG90b246IHBob3RvbixcbiAgICBXaGF0M1dvcmRzOiBXaGF0M1dvcmRzLFxuICAgIHdoYXQzd29yZHM6IHdoYXQzd29yZHNcbiAgfTtcblxuICAvKipcclxuICAgKiBMZWFmbGV0IG1peGlucyBodHRwczovL2xlYWZsZXRqcy5jb20vcmVmZXJlbmNlLTEuNy4xLmh0bWwjY2xhc3MtaW5jbHVkZXNcclxuICAgKiBmb3IgVHlwZVNjcmlwdCBodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvZG9jcy9oYW5kYm9vay9taXhpbnMuaHRtbFxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xuXG4gIHZhciBFdmVudGVkQ29udHJvbCA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgZnVuY3Rpb24gRXZlbnRlZENvbnRyb2woKSB7Ly8gZW1wdHlcbiAgfTtcblxuICBMX19uYW1lc3BhY2UuVXRpbC5leHRlbmQoRXZlbnRlZENvbnRyb2wucHJvdG90eXBlLCBMX19uYW1lc3BhY2UuQ29udHJvbC5wcm90b3R5cGUpO1xuICBMX19uYW1lc3BhY2UuVXRpbC5leHRlbmQoRXZlbnRlZENvbnRyb2wucHJvdG90eXBlLCBMX19uYW1lc3BhY2UuRXZlbnRlZC5wcm90b3R5cGUpO1xuICAvKipcclxuICAgKiBUaGlzIGlzIHRoZSBnZW9jb2RlciBjb250cm9sLiBJdCB3b3JrcyBsaWtlIGFueSBvdGhlciBbTGVhZmxldCBjb250cm9sXShodHRwczovL2xlYWZsZXRqcy5jb20vcmVmZXJlbmNlLmh0bWwjY29udHJvbCksIGFuZCBpcyBhZGRlZCB0byB0aGUgbWFwLlxyXG4gICAqL1xuXG4gIHZhciBHZW9jb2RlckNvbnRyb2wgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FdmVudGVkQ29udHJvbCkge1xuICAgIF9pbmhlcml0c0xvb3NlKEdlb2NvZGVyQ29udHJvbCwgX0V2ZW50ZWRDb250cm9sKTtcblxuICAgIC8qKlxyXG4gICAgICogSW5zdGFudGlhdGVzIGEgZ2VvY29kZXIgY29udHJvbCAodG8gYmUgaW52b2tlZCB1c2luZyBgbmV3YClcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBHZW9jb2RlckNvbnRyb2wob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfdGhpcyA9IF9FdmVudGVkQ29udHJvbC5jYWxsKHRoaXMsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICBfdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBzaG93VW5pcXVlUmVzdWx0OiB0cnVlLFxuICAgICAgICBzaG93UmVzdWx0SWNvbnM6IGZhbHNlLFxuICAgICAgICBjb2xsYXBzZWQ6IHRydWUsXG4gICAgICAgIGV4cGFuZDogJ3RvdWNoJyxcbiAgICAgICAgcG9zaXRpb246ICd0b3ByaWdodCcsXG4gICAgICAgIHBsYWNlaG9sZGVyOiAnU2VhcmNoLi4uJyxcbiAgICAgICAgZXJyb3JNZXNzYWdlOiAnTm90aGluZyBmb3VuZC4nLFxuICAgICAgICBpY29uTGFiZWw6ICdJbml0aWF0ZSBhIG5ldyBzZWFyY2gnLFxuICAgICAgICBxdWVyeTogJycsXG4gICAgICAgIHF1ZXJ5TWluTGVuZ3RoOiAxLFxuICAgICAgICBzdWdnZXN0TWluTGVuZ3RoOiAzLFxuICAgICAgICBzdWdnZXN0VGltZW91dDogMjUwLFxuICAgICAgICBkZWZhdWx0TWFya0dlb2NvZGU6IHRydWVcbiAgICAgIH07XG4gICAgICBfdGhpcy5fcmVxdWVzdENvdW50ID0gMDtcbiAgICAgIExfX25hbWVzcGFjZS5VdGlsLnNldE9wdGlvbnMoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoIV90aGlzLm9wdGlvbnMuZ2VvY29kZXIpIHtcbiAgICAgICAgX3RoaXMub3B0aW9ucy5nZW9jb2RlciA9IG5ldyBOb21pbmF0aW0oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBHZW9jb2RlckNvbnRyb2wucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmFkZFRocm9iYmVyQ2xhc3MgPSBmdW5jdGlvbiBhZGRUaHJvYmJlckNsYXNzKCkge1xuICAgICAgTF9fbmFtZXNwYWNlLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWdlb2NvZGVyLXRocm9iYmVyJyk7XG4gICAgfTtcblxuICAgIF9wcm90by5yZW1vdmVUaHJvYmJlckNsYXNzID0gZnVuY3Rpb24gcmVtb3ZlVGhyb2JiZXJDbGFzcygpIHtcbiAgICAgIExfX25hbWVzcGFjZS5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci10aHJvYmJlcicpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNvbnRhaW5lciBET00gZWxlbWVudCBmb3IgdGhlIGNvbnRyb2wgYW5kIGFkZCBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy5cclxuICAgICAqIEBwYXJhbSBtYXAgdGhlIG1hcCBpbnN0YW5jZVxyXG4gICAgICogQHNlZSBodHRwczovL2xlYWZsZXRqcy5jb20vcmVmZXJlbmNlLmh0bWwjY29udHJvbC1vbmFkZFxyXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLm9uQWRkID0gZnVuY3Rpb24gb25BZGQobWFwKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXInO1xuICAgICAgdmFyIGNvbnRhaW5lciA9IExfX25hbWVzcGFjZS5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJyBsZWFmbGV0LWJhcicpO1xuICAgICAgdmFyIGljb24gPSBMX19uYW1lc3BhY2UuRG9tVXRpbC5jcmVhdGUoJ2J1dHRvbicsIGNsYXNzTmFtZSArICctaWNvbicsIGNvbnRhaW5lcik7XG4gICAgICB2YXIgZm9ybSA9IHRoaXMuX2Zvcm0gPSBMX19uYW1lc3BhY2UuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctZm9ybScsIGNvbnRhaW5lcik7XG4gICAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICBpY29uLmlubmVySFRNTCA9ICcmbmJzcDsnO1xuICAgICAgaWNvbi50eXBlID0gJ2J1dHRvbic7XG4gICAgICBpY29uLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHRoaXMub3B0aW9ucy5pY29uTGFiZWwpO1xuICAgICAgdmFyIGlucHV0ID0gdGhpcy5faW5wdXQgPSBMX19uYW1lc3BhY2UuRG9tVXRpbC5jcmVhdGUoJ2lucHV0JywgJycsIGZvcm0pO1xuICAgICAgaW5wdXQudHlwZSA9ICd0ZXh0JztcbiAgICAgIGlucHV0LnZhbHVlID0gdGhpcy5vcHRpb25zLnF1ZXJ5O1xuICAgICAgaW5wdXQucGxhY2Vob2xkZXIgPSB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXI7XG4gICAgICBMX19uYW1lc3BhY2UuRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oaW5wdXQpO1xuICAgICAgdGhpcy5fZXJyb3JFbGVtZW50ID0gTF9fbmFtZXNwYWNlLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLWZvcm0tbm8tZXJyb3InLCBjb250YWluZXIpO1xuICAgICAgdGhpcy5fZXJyb3JFbGVtZW50LmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5lcnJvck1lc3NhZ2U7XG4gICAgICB0aGlzLl9hbHRzID0gTF9fbmFtZXNwYWNlLkRvbVV0aWwuY3JlYXRlKCd1bCcsIGNsYXNzTmFtZSArICctYWx0ZXJuYXRpdmVzIGxlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1hbHRlcm5hdGl2ZXMtbWluaW1pemVkJywgY29udGFpbmVyKTtcbiAgICAgIExfX25hbWVzcGFjZS5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aGlzLl9hbHRzKTtcbiAgICAgIExfX25hbWVzcGFjZS5Eb21FdmVudC5hZGRMaXN0ZW5lcihpbnB1dCwgJ2tleWRvd24nLCB0aGlzLl9rZXlkb3duLCB0aGlzKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5nZW9jb2Rlci5zdWdnZXN0KSB7XG4gICAgICAgIExfX25hbWVzcGFjZS5Eb21FdmVudC5hZGRMaXN0ZW5lcihpbnB1dCwgJ2lucHV0JywgdGhpcy5fY2hhbmdlLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgTF9fbmFtZXNwYWNlLkRvbUV2ZW50LmFkZExpc3RlbmVyKGlucHV0LCAnYmx1cicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zLmNvbGxhcHNlZCAmJiAhX3RoaXMyLl9wcmV2ZW50Qmx1ckNvbGxhcHNlKSB7XG4gICAgICAgICAgX3RoaXMyLl9jb2xsYXBzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMyLl9wcmV2ZW50Qmx1ckNvbGxhcHNlID0gZmFsc2U7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb2xsYXBzZWQpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHBhbmQgPT09ICdjbGljaycpIHtcbiAgICAgICAgICBMX19uYW1lc3BhY2UuRG9tRXZlbnQuYWRkTGlzdGVuZXIoY29udGFpbmVyLCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUuYnV0dG9uID09PSAwICYmIGUuZGV0YWlsICE9PSAyKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5fdG9nZ2xlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmV4cGFuZCA9PT0gJ3RvdWNoJykge1xuICAgICAgICAgIExfX25hbWVzcGFjZS5Eb21FdmVudC5hZGRMaXN0ZW5lcihjb250YWluZXIsIExfX25hbWVzcGFjZS5Ccm93c2VyLnRvdWNoID8gJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyA6ICdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXMyLl90b2dnbGUoKTtcblxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBtb2JpbGU6IGNsaWNraW5nIGZvY3VzZXMgdGhlIGljb24sIHNvIFVJIGV4cGFuZHMgYW5kIGltbWVkaWF0ZWx5IGNvbGxhcHNlc1xuXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIExfX25hbWVzcGFjZS5Eb21FdmVudC5hZGRMaXN0ZW5lcihjb250YWluZXIsICdtb3VzZW92ZXInLCB0aGlzLl9leHBhbmQsIHRoaXMpO1xuICAgICAgICAgIExfX25hbWVzcGFjZS5Eb21FdmVudC5hZGRMaXN0ZW5lcihjb250YWluZXIsICdtb3VzZW91dCcsIHRoaXMuX2NvbGxhcHNlLCB0aGlzKTtcblxuICAgICAgICAgIHRoaXMuX21hcC5vbignbW92ZXN0YXJ0JywgdGhpcy5fY29sbGFwc2UsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9leHBhbmQoKTtcblxuICAgICAgICBpZiAoTF9fbmFtZXNwYWNlLkJyb3dzZXIudG91Y2gpIHtcbiAgICAgICAgICBMX19uYW1lc3BhY2UuRG9tRXZlbnQuYWRkTGlzdGVuZXIoY29udGFpbmVyLCAndG91Y2hzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIuX2dlb2NvZGUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBMX19uYW1lc3BhY2UuRG9tRXZlbnQuYWRkTGlzdGVuZXIoY29udGFpbmVyLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLl9nZW9jb2RlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWZhdWx0TWFya0dlb2NvZGUpIHtcbiAgICAgICAgdGhpcy5vbignbWFya2dlb2NvZGUnLCB0aGlzLm1hcmtHZW9jb2RlLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vbignc3RhcnRnZW9jb2RlJywgdGhpcy5hZGRUaHJvYmJlckNsYXNzLCB0aGlzKTtcbiAgICAgIHRoaXMub24oJ2ZpbmlzaGdlb2NvZGUnLCB0aGlzLnJlbW92ZVRocm9iYmVyQ2xhc3MsIHRoaXMpO1xuICAgICAgdGhpcy5vbignc3RhcnRzdWdnZXN0JywgdGhpcy5hZGRUaHJvYmJlckNsYXNzLCB0aGlzKTtcbiAgICAgIHRoaXMub24oJ2ZpbmlzaHN1Z2dlc3QnLCB0aGlzLnJlbW92ZVRocm9iYmVyQ2xhc3MsIHRoaXMpO1xuICAgICAgTF9fbmFtZXNwYWNlLkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcik7XG4gICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHF1ZXJ5IHN0cmluZyBvbiB0aGUgdGV4dCBpbnB1dFxyXG4gICAgICogQHBhcmFtIHN0cmluZyB0aGUgcXVlcnkgc3RyaW5nXHJcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uc2V0UXVlcnkgPSBmdW5jdGlvbiBzZXRRdWVyeShzdHJpbmcpIHtcbiAgICAgIHRoaXMuX2lucHV0LnZhbHVlID0gc3RyaW5nO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIF9wcm90by5fZ2VvY29kZVJlc3VsdCA9IGZ1bmN0aW9uIF9nZW9jb2RlUmVzdWx0KHJlc3VsdHMsIHN1Z2dlc3QpIHtcbiAgICAgIGlmICghc3VnZ2VzdCAmJiB0aGlzLm9wdGlvbnMuc2hvd1VuaXF1ZVJlc3VsdCAmJiByZXN1bHRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLl9nZW9jb2RlUmVzdWx0U2VsZWN0ZWQocmVzdWx0c1swXSk7XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLl9hbHRzLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0aGlzLl9yZXN1bHRzID0gcmVzdWx0cztcbiAgICAgICAgTF9fbmFtZXNwYWNlLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fYWx0cywgJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1hbHRlcm5hdGl2ZXMtbWluaW1pemVkJyk7XG4gICAgICAgIExfX25hbWVzcGFjZS5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1vcHRpb25zLW9wZW4nKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl9hbHRzLmFwcGVuZENoaWxkKHRoaXMuX2NyZWF0ZUFsdChyZXN1bHRzW2ldLCBpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIExfX25hbWVzcGFjZS5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1vcHRpb25zLWVycm9yJyk7XG4gICAgICAgIExfX25hbWVzcGFjZS5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2Vycm9yRWxlbWVudCwgJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1lcnJvcicpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIE1hcmtzIGEgZ2VvY29kaW5nIHJlc3VsdCBvbiB0aGUgbWFwXHJcbiAgICAgKiBAcGFyYW0gcmVzdWx0IHRoZSBnZW9jb2RpbmcgcmVzdWx0XHJcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8ubWFya0dlb2NvZGUgPSBmdW5jdGlvbiBtYXJrR2VvY29kZShldmVudCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGV2ZW50Lmdlb2NvZGU7XG5cbiAgICAgIHRoaXMuX21hcC5maXRCb3VuZHMocmVzdWx0LmJib3gpO1xuXG4gICAgICBpZiAodGhpcy5fZ2VvY29kZU1hcmtlcikge1xuICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fZ2VvY29kZU1hcmtlcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2dlb2NvZGVNYXJrZXIgPSBuZXcgTF9fbmFtZXNwYWNlLk1hcmtlcihyZXN1bHQuY2VudGVyKS5iaW5kUG9wdXAocmVzdWx0Lmh0bWwgfHwgcmVzdWx0Lm5hbWUpLmFkZFRvKHRoaXMuX21hcCkub3BlblBvcHVwKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9nZW9jb2RlID0gZnVuY3Rpb24gX2dlb2NvZGUoc3VnZ2VzdCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2lucHV0LnZhbHVlO1xuXG4gICAgICBpZiAoIXN1Z2dlc3QgJiYgdmFsdWUubGVuZ3RoIDwgdGhpcy5vcHRpb25zLnF1ZXJ5TWluTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcXVlc3RDb3VudCA9ICsrdGhpcy5fcmVxdWVzdENvdW50O1xuXG4gICAgICB2YXIgY2IgPSBmdW5jdGlvbiBjYihyZXN1bHRzKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0Q291bnQgPT09IF90aGlzMy5fcmVxdWVzdENvdW50KSB7XG4gICAgICAgICAgdmFyIF9ldmVudCA9IHtcbiAgICAgICAgICAgIGlucHV0OiB2YWx1ZSxcbiAgICAgICAgICAgIHJlc3VsdHM6IHJlc3VsdHNcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX3RoaXMzLmZpcmUoc3VnZ2VzdCA/ICdmaW5pc2hzdWdnZXN0JyA6ICdmaW5pc2hnZW9jb2RlJywgX2V2ZW50KTtcblxuICAgICAgICAgIF90aGlzMy5fZ2VvY29kZVJlc3VsdChyZXN1bHRzLCBzdWdnZXN0KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5fbGFzdEdlb2NvZGUgPSB2YWx1ZTtcblxuICAgICAgaWYgKCFzdWdnZXN0KSB7XG4gICAgICAgIHRoaXMuX2NsZWFyUmVzdWx0cygpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgIGlucHV0OiB2YWx1ZVxuICAgICAgfTtcbiAgICAgIHRoaXMuZmlyZShzdWdnZXN0ID8gJ3N0YXJ0c3VnZ2VzdCcgOiAnc3RhcnRnZW9jb2RlJywgZXZlbnQpO1xuXG4gICAgICBpZiAoc3VnZ2VzdCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZ2VvY29kZXIuc3VnZ2VzdCh2YWx1ZSwgY2IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmdlb2NvZGVyLmdlb2NvZGUodmFsdWUsIGNiKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLl9nZW9jb2RlUmVzdWx0U2VsZWN0ZWQgPSBmdW5jdGlvbiBfZ2VvY29kZVJlc3VsdFNlbGVjdGVkKGdlb2NvZGUpIHtcbiAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgZ2VvY29kZTogZ2VvY29kZVxuICAgICAgfTtcbiAgICAgIHRoaXMuZmlyZSgnbWFya2dlb2NvZGUnLCBldmVudCk7XG4gICAgfTtcblxuICAgIF9wcm90by5fdG9nZ2xlID0gZnVuY3Rpb24gX3RvZ2dsZSgpIHtcbiAgICAgIGlmIChMX19uYW1lc3BhY2UuRG9tVXRpbC5oYXNDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItZXhwYW5kZWQnKSkge1xuICAgICAgICB0aGlzLl9jb2xsYXBzZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZXhwYW5kKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5fZXhwYW5kID0gZnVuY3Rpb24gX2V4cGFuZCgpIHtcbiAgICAgIExfX25hbWVzcGFjZS5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1leHBhbmRlZCcpO1xuXG4gICAgICB0aGlzLl9pbnB1dC5zZWxlY3QoKTtcblxuICAgICAgdGhpcy5maXJlKCdleHBhbmQnKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9jb2xsYXBzZSA9IGZ1bmN0aW9uIF9jb2xsYXBzZSgpIHtcbiAgICAgIExfX25hbWVzcGFjZS5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1leHBhbmRlZCcpO1xuICAgICAgTF9fbmFtZXNwYWNlLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fYWx0cywgJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1hbHRlcm5hdGl2ZXMtbWluaW1pemVkJyk7XG4gICAgICBMX19uYW1lc3BhY2UuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9lcnJvckVsZW1lbnQsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItZXJyb3InKTtcbiAgICAgIExfX25hbWVzcGFjZS5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1vcHRpb25zLW9wZW4nKTtcbiAgICAgIExfX25hbWVzcGFjZS5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1vcHRpb25zLWVycm9yJyk7XG5cbiAgICAgIHRoaXMuX2lucHV0LmJsdXIoKTsgLy8gbW9iaWxlOiBrZXlib2FyZCBzaG91bGRuJ3Qgc3RheSBleHBhbmRlZFxuXG5cbiAgICAgIHRoaXMuZmlyZSgnY29sbGFwc2UnKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9jbGVhclJlc3VsdHMgPSBmdW5jdGlvbiBfY2xlYXJSZXN1bHRzKCkge1xuICAgICAgTF9fbmFtZXNwYWNlLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fYWx0cywgJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1hbHRlcm5hdGl2ZXMtbWluaW1pemVkJyk7XG4gICAgICB0aGlzLl9zZWxlY3Rpb24gPSBudWxsO1xuICAgICAgTF9fbmFtZXNwYWNlLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fZXJyb3JFbGVtZW50LCAnbGVhZmxldC1jb250cm9sLWdlb2NvZGVyLWVycm9yJyk7XG4gICAgICBMX19uYW1lc3BhY2UuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItb3B0aW9ucy1vcGVuJyk7XG4gICAgICBMX19uYW1lc3BhY2UuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItb3B0aW9ucy1lcnJvcicpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uX2NyZWF0ZUFsdCA9IGZ1bmN0aW9uIF9jcmVhdGVBbHQocmVzdWx0LCBpbmRleCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBsaSA9IExfX25hbWVzcGFjZS5Eb21VdGlsLmNyZWF0ZSgnbGknLCAnJyksXG4gICAgICAgICAgYSA9IExfX25hbWVzcGFjZS5Eb21VdGlsLmNyZWF0ZSgnYScsICcnLCBsaSksXG4gICAgICAgICAgaWNvbiA9IHRoaXMub3B0aW9ucy5zaG93UmVzdWx0SWNvbnMgJiYgcmVzdWx0Lmljb24gPyBMX19uYW1lc3BhY2UuRG9tVXRpbC5jcmVhdGUoJ2ltZycsICcnLCBhKSA6IG51bGwsXG4gICAgICAgICAgdGV4dCA9IHJlc3VsdC5odG1sID8gdW5kZWZpbmVkIDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocmVzdWx0Lm5hbWUpLFxuICAgICAgICAgIG1vdXNlRG93bkhhbmRsZXIgPSBmdW5jdGlvbiBtb3VzZURvd25IYW5kbGVyKGUpIHtcbiAgICAgICAgLy8gSW4gc29tZSBicm93c2VycywgYSBjbGljayB3aWxsIGZpcmUgb24gdGhlIG1hcCBpZiB0aGUgY29udHJvbCBpc1xuICAgICAgICAvLyBjb2xsYXBzZWQgZGlyZWN0bHkgYWZ0ZXIgbW91c2Vkb3duLiBUbyB3b3JrIGFyb3VuZCB0aGlzLCB3ZVxuICAgICAgICAvLyB3YWl0IHVudGlsIHRoZSBjbGljayBpcyBjb21wbGV0ZWQsIGFuZCBfdGhlbl8gY29sbGFwc2UgdGhlXG4gICAgICAgIC8vIGNvbnRyb2wuIE1lc3N5LCBidXQgdGhpcyBpcyB0aGUgd29ya2Fyb3VuZCBJIGNvdWxkIGNvbWUgdXAgd2l0aFxuICAgICAgICAvLyBmb3IgIzE0Mi5cbiAgICAgICAgX3RoaXM0Ll9wcmV2ZW50Qmx1ckNvbGxhcHNlID0gdHJ1ZTtcbiAgICAgICAgTF9fbmFtZXNwYWNlLkRvbUV2ZW50LnN0b3AoZSk7XG5cbiAgICAgICAgX3RoaXM0Ll9nZW9jb2RlUmVzdWx0U2VsZWN0ZWQocmVzdWx0KTtcblxuICAgICAgICBMX19uYW1lc3BhY2UuRG9tRXZlbnQub24obGksICdjbGljayB0b3VjaGVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXM0Lm9wdGlvbnMuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICBfdGhpczQuX2NvbGxhcHNlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzNC5fY2xlYXJSZXN1bHRzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChpY29uKSB7XG4gICAgICAgIGljb24uc3JjID0gcmVzdWx0Lmljb247XG4gICAgICB9XG5cbiAgICAgIGxpLnNldEF0dHJpYnV0ZSgnZGF0YS1yZXN1bHQtaW5kZXgnLCBTdHJpbmcoaW5kZXgpKTtcblxuICAgICAgaWYgKHJlc3VsdC5odG1sKSB7XG4gICAgICAgIGEuaW5uZXJIVE1MID0gYS5pbm5lckhUTUwgKyByZXN1bHQuaHRtbDtcbiAgICAgIH0gZWxzZSBpZiAodGV4dCkge1xuICAgICAgICBhLmFwcGVuZENoaWxkKHRleHQpO1xuICAgICAgfSAvLyBVc2UgbW91c2Vkb3duIGFuZCBub3QgY2xpY2ssIHNpbmNlIGNsaWNrIHdpbGwgZmlyZSBfYWZ0ZXJfIGJsdXIsXG4gICAgICAvLyBjYXVzaW5nIHRoZSBjb250cm9sIHRvIGhhdmUgY29sbGFwc2VkIGFuZCByZW1vdmVkIHRoZSBpdGVtc1xuICAgICAgLy8gYmVmb3JlIHRoZSBjbGljayBjYW4gZmlyZS5cblxuXG4gICAgICBMX19uYW1lc3BhY2UuRG9tRXZlbnQuYWRkTGlzdGVuZXIobGksICdtb3VzZWRvd24gdG91Y2hzdGFydCcsIG1vdXNlRG93bkhhbmRsZXIsIHRoaXMpO1xuICAgICAgcmV0dXJuIGxpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uX2tleWRvd24gPSBmdW5jdGlvbiBfa2V5ZG93bihlKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIHNlbGVjdCA9IGZ1bmN0aW9uIHNlbGVjdChkaXIpIHtcbiAgICAgICAgaWYgKF90aGlzNS5fc2VsZWN0aW9uKSB7XG4gICAgICAgICAgTF9fbmFtZXNwYWNlLkRvbVV0aWwucmVtb3ZlQ2xhc3MoX3RoaXM1Ll9zZWxlY3Rpb24sICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItc2VsZWN0ZWQnKTtcbiAgICAgICAgICBfdGhpczUuX3NlbGVjdGlvbiA9IF90aGlzNS5fc2VsZWN0aW9uW2RpciA+IDAgPyAnbmV4dFNpYmxpbmcnIDogJ3ByZXZpb3VzU2libGluZyddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFfdGhpczUuX3NlbGVjdGlvbikge1xuICAgICAgICAgIF90aGlzNS5fc2VsZWN0aW9uID0gX3RoaXM1Ll9hbHRzW2RpciA+IDAgPyAnZmlyc3RDaGlsZCcgOiAnbGFzdENoaWxkJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXM1Ll9zZWxlY3Rpb24pIHtcbiAgICAgICAgICBMX19uYW1lc3BhY2UuRG9tVXRpbC5hZGRDbGFzcyhfdGhpczUuX3NlbGVjdGlvbiwgJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1zZWxlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgICAvLyBFc2NhcGVcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgdGhpcy5fY29sbGFwc2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJSZXN1bHRzKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFVwXG5cbiAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICBzZWxlY3QoLTEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBVcFxuXG4gICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgc2VsZWN0KDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBFbnRlclxuXG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQodGhpcy5fc2VsZWN0aW9uLmdldEF0dHJpYnV0ZSgnZGF0YS1yZXN1bHQtaW5kZXgnKSwgMTApO1xuXG4gICAgICAgICAgICB0aGlzLl9nZW9jb2RlUmVzdWx0U2VsZWN0ZWQodGhpcy5fcmVzdWx0c1tpbmRleF0pO1xuXG4gICAgICAgICAgICB0aGlzLl9jbGVhclJlc3VsdHMoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZ2VvY29kZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBMX19uYW1lc3BhY2UuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG4gICAgfTtcblxuICAgIF9wcm90by5fY2hhbmdlID0gZnVuY3Rpb24gX2NoYW5nZSgpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICB2YXIgdiA9IHRoaXMuX2lucHV0LnZhbHVlO1xuXG4gICAgICBpZiAodiAhPT0gdGhpcy5fbGFzdEdlb2NvZGUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3N1Z2dlc3RUaW1lb3V0KTtcblxuICAgICAgICBpZiAodi5sZW5ndGggPj0gdGhpcy5vcHRpb25zLnN1Z2dlc3RNaW5MZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl9zdWdnZXN0VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzNi5fZ2VvY29kZSh0cnVlKTtcbiAgICAgICAgICB9LCB0aGlzLm9wdGlvbnMuc3VnZ2VzdFRpbWVvdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2NsZWFyUmVzdWx0cygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBHZW9jb2RlckNvbnRyb2w7XG4gIH0oRXZlbnRlZENvbnRyb2wpO1xuICAvKipcclxuICAgKiBbQ2xhc3MgZmFjdG9yeSBtZXRob2RdKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9yZWZlcmVuY2UuaHRtbCNjbGFzcy1jbGFzcy1mYWN0b3JpZXMpIGZvciB7QGxpbmsgR2VvY29kZXJDb250cm9sfVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gZ2VvY29kZXIob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgR2VvY29kZXJDb250cm9sKG9wdGlvbnMpO1xuICB9XG5cbiAgLyogQHByZXNlcnZlXHJcbiAgICogTGVhZmxldCBDb250cm9sIEdlb2NvZGVyXHJcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3BlcmxpZWRtYW4vbGVhZmxldC1jb250cm9sLWdlb2NvZGVyXHJcbiAgICpcclxuICAgKiBDb3B5cmlnaHQgKGMpIDIwMTIgc2EzbSAoaHR0cHM6Ly9naXRodWIuY29tL3NhM20pXHJcbiAgICogQ29weXJpZ2h0IChjKSAyMDE4IFBlciBMaWVkbWFuXHJcbiAgICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICAgKi9cbiAgTF9fbmFtZXNwYWNlLlV0aWwuZXh0ZW5kKEdlb2NvZGVyQ29udHJvbCwgZ2VvY29kZXJzKTtcbiAgTF9fbmFtZXNwYWNlLlV0aWwuZXh0ZW5kKExfX25hbWVzcGFjZS5Db250cm9sLCB7XG4gICAgR2VvY29kZXI6IEdlb2NvZGVyQ29udHJvbCxcbiAgICBnZW9jb2RlcjogZ2VvY29kZXJcbiAgfSk7XG5cbiAgZXhwb3J0cy5HZW9jb2RlciA9IEdlb2NvZGVyQ29udHJvbDtcbiAgZXhwb3J0cy5kZWZhdWx0ID0gR2VvY29kZXJDb250cm9sO1xuICBleHBvcnRzLmdlb2NvZGVyID0gZ2VvY29kZXI7XG4gIGV4cG9ydHMuZ2VvY29kZXJzID0gZ2VvY29kZXJzO1xuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KHt9LCBMKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db250cm9sLkdlb2NvZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/leaflet-control-geocoder/dist/Control.Geocoder.js\n");

/***/ })

};
;